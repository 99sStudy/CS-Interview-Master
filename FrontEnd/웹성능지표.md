# ✨웹 성능을 최적화하기 위한 핵심 지표(LCP, FID, CLS 등)에 대해 설명하고, 이러한 지표를 개선하기 위해 프로젝트에서 어떤 방법들을 사용했는지 구체적인 사례를 들어 설명해 주세요.

웹 성능 최적화는 사용자 경험을 향상시키고, 검색 엔진 최적화(SEO)에 긍정적인 영향을 미치는 중요한 요소입니다.

## 1. 핵심 지표

### 📖FP (First Paint) [렌더링 관련 지표]

- Paint timing API 에서 제공. `페이지로 이동한 시각부터 첫 번째 픽셀이 화면에 그려지기까지 사이의 시간`을 나타낸다.

### 📖FCP (First Contentful Paint) [렌더링 관련 지표]

- 사용자가 웹페이지 로딩을 시작할 때부터 페이지 콘텐츠의 일부가 화면에 렌더링될 때까지 걸리는 시간
- 이 콘텐츠에는 `텍스트, 이미지, SVG 또는 컬러 캔버스 요소`가 포함될 수 있습니다.
- 유저가 처음으로 컨텐츠를 소비하기 시작하는 시간이다.
- 우수한 사용자 경험을 제공하려면 FCP는 1.8초 이하여야 한다.
- FCP를 최적화하기 위한 방법으로 `렌더링 차단 리소스 제거`, `CSS 축소`, `핵심 요청 사전 로드`, `캐시 활용`, `요청 깊이 최소화` 등이 있다.
- FCP를 개선하려면 다음 전략을 고려하세요:
  - 서버 응답 시간 최적화: 서버가 요청에 빠르게 응답하는지 확인하세요.
  - 렌더링을 차단하는 리소스를 최소화합니다: 렌더링을 차단하는 JavaScript 및 CSS를 연기하거나 제거합니다.
  - CSS 및 자바스크립트 최적화: 이러한 파일을 축소 및 압축하여 크기를 줄이고 로딩 시간을 개선하세요.
  - 주요 리소스 미리 로드하기: 중요한 리소스의 로드 우선순위를 지정하려면 <link rel="preload">를 사용하세요.
  - CDN(콘텐츠 전송 네트워크)을 사용합니다: 여러 서버에 콘텐츠를 분산하여 전 세계 사용자의 로드 시간을 개선하세요

### 📖LCP (Largest Contentful Paint) [렌더링 관련 지표]

- 정의: 페이지에서 `가장 큰 콘텐츠 요소(예: 이미지, 비디오, 텍스트 블록)가 사용자에게 렌더링되는 데 걸리는 시간을 측정`합니다.
- 중요성: LCP는 사용자에게 페이지가 로드되고 있음을 인식할 수 있는 중요한 지표입니다. LCP가 2.5초 이하일 때 좋은 성능으로 간주됩니다.

### 📖TTI (Time to Interactive)

- 정의 : `페이지가 로드되기 시작`한 시점부터 주요 하위 리소스가 로드된 후 `사용자 입력에 안정적으로 응답할 수 있게 되기까지`의 시간이다.
- SSR과 같은 기술을 사용하면 표시 속도는 빨라지지만 TTI가 희생될 수 있다.

### 📖FID (First Input Delay) [반응 속도 관련 지표]

- 정의: 사용자가 페이지와 `상호작용을 시작한 후, 브라우저가 실제로 반응하기까지의 시간을 측정`합니다. 예를 들어, 버튼 클릭이나 링크 클릭 시의 지연 시간을 측정합니다.
- 중요성: FID는 사용자 경험의 즉각성을 나타내며, 100ms 이하일 때 좋은 성능으로 간주됩니다.

### FID의 한계점

2020년 구글에서 Web Core Vitals 지표 발표 이후 Web Core Vitals의 3대 지표 중 하나인 FID 지표에는 한계점이 존재했습니다.

즉, 사용자는 `첫번째 입력값 뿐만 아니라 사용자의 모든 입력 반응성을 반영하지 못했습니다`.

이에 구글에서는 서두에 말씀드렸듯이 FID를 포괄하는 새로운 지표를 만들어 웹 성능 지표인 Web Core Vitals를 개선하고자 했습니다.

### INP의 도입 (INP : Interaction to Next Paint)

위와 같은 FID의 한계점 때문에 구글은 2024년 3월에 FID라는 지표를 대체하여 INP라는 새로운 지표를 사용하려고 합니다.

INP란 `사용자가 페이지를 방문하여 전체 기간동안 발생하는 모든 클릭, 탭, 키보드의 상호작용을 관찰하여 사용자 상호작용에 대한 페이지의 전반적인 응답성을 평가하는 측정지표`입니다.

첫번째 입력뿐만 아니라 `웹사이트 사용자의 입력 반응성을 고려하는게 필요`했고, 이벤트 지연시간 뿐만 아니라 `전체시간 확인이 필요`했습니다.

그리고 이벤트 입력시간 뿐만 아니라 엔드투엔드로 사용자의 시간까지 확인하려고 합니다.

INP는 마우스 클릭 혹은 터치스크린의 경우 기기를 탭하는 경우, 키보드 입력 값의 경우의 유형만 관찰됩니다

### 📖CLS (Cumulative Layout Shift) [UI 안정성]

- 정의: 페이지의 `레이아웃이 얼마나 자주 변경되는지를 측정`합니다. 사용자가 페이지를 읽는 동안 예상치 못한 레이아웃 변경이 발생하면 사용자 경험이 저하됩니다.
- 중요성: CLS는 0.1 이하일 때 좋은 성능으로 간주되며, 레이아웃 안정성을 나타냅니다.

## 2. 지표 개선을 위한 방법과 사례

### 🚨 FCP 개선

1. **HTML과 CSS 렌더링 최적화**
   - **Critical CSS 적용**: 중요한 CSS만 먼저 로드하여 페이지의 핵심 콘텐츠가 최대한 빨리 렌더링될 수 있도록 합니다.
   - **CSS 지연 로딩**: 화면을 구성하는 데 중요하지 않은 CSS 파일은 `media="print"`와 같은 속성을 사용하여 지연 로드합니다.
2. **이미지 및 리소스 최적화**

   - **이미지 압축** 및 **최적화된 포맷(WebP)** 사용으로 FCP를 단축할 수 있습니다.
   - **Lazy Loading**을 통해 페이지 하단에 있는 이미지는 초기 로딩에 포함되지 않도록 처리합니다.

3. **브라우저 캐싱 및 CDN 활용**

   - **CDN**을 사용해 리소스를 사용자 가까운 곳에서 빠르게 로드할 수 있도록 하며, **브라우저 캐싱**으로 자주 사용되는 리소스는 캐시에서 재사용하여 FCP를 개선합니다.

4. **프리로딩(Preloading)**
   - 초기 렌더링에 필요한 폰트, 핵심 이미지, 주요 CSS 및 JavaScript 파일을 `<link rel="preload">`로 미리 로드하여 로딩 속도를 향상시킵니다.

---

### 🚨 TTI 개선

1. **코드 스플리팅 및 지연 로딩**
   - **코드 스플리팅(Code Splitting)**: 주요 기능을 구현하는 코드와 나중에 로드할 코드로 나눠, 초기 로딩 시 불필요한 코드를 최소화합니다. 이를 통해 TTI까지의 시간을 단축할 수 있습니다.
   - 예: Webpack이나 Parcel 같은 번들러에서 코드 스플리팅을 설정하여 페이지 초기화 시 필요한 모듈만 로드하게 할 수 있습니다.
2. **JavaScript 최적화**

   - **불필요한 스크립트 삭제 및 정리**: 불필요한 JavaScript나 사용하지 않는 라이브러리를 삭제하여 메인 스레드의 작업 부하를 줄입니다.
   - **비동기 로딩**: `async`나 `defer` 속성을 사용해 주요 작업과 상관없는 JavaScript는 비동기 또는 지연 로딩하여 메인 스레드가 신속하게 상호작용을 처리할 수 있게 합니다.

3. **웹 작업(Web Worker) 사용**

   - **Web Worker**를 통해 복잡한 계산이나 비동기 처리를 메인 스레드에서 분리하여 페이지가 빨리 상호작용 가능하도록 만듭니다.
   - 특히 애니메이션 처리나 데이터 계산과 같은 작업을 Web Worker로 옮기면 TTI가 개선됩니다.

4. **서버 요청 및 API 최적화**

   - **지연 로딩(Lazy Loading)**: 페이지 초기에는 필요하지 않은 API 요청은 사용자가 상호작용을 시도할 때 로드되도록 처리합니다.
   - **API 응답 최적화**: 서버에서 데이터 크기를 최소화하고, 필요한 데이터만 전송하여 불필요한 대기 시간을 줄입니다.

5. **프리로딩 및 프리페칭**
   - 사용자 상호작용이 예상되는 주요 리소스는 **프리로딩**을 통해 미리 로드하여 TTI를 단축하고, 이후 페이지 이동이 예상되는 경우 **프리페칭**으로 미리 로드할 수 있습니다.
   - 예: `<link rel="prefetch" href="next-page.js" as="script">`를 사용해 사용자 상호작용이 발생할 가능성이 높은 리소스를 미리 로드합니다.

### 🚨 LCP 개선

- `이미지 최적화:`

  - 이미지 파일 크기를 줄이기 위해 `ImageKit`이나 `Cloudinary`와 같은 이미지 최적화 서비스를 사용했습니다.

  - `WebP`와 같은 현대적인 이미지 포맷을 사용하여 로딩 속도를 개선했습니다.

- `지연 로딩(Lazy Loading):`

  - React의 `React.lazy`와 `Suspense`를 사용하여 화면에 보이지 않는 컴포넌트를 지연 로딩했습니다.

  - 이미지에 대해서는 `loading="lazy"` 속성을 추가하여 브라우저가 뷰포트에 들어오는 시점에만 로드하도록 했습니다.

- `CDN 사용`: 콘텐츠 전송 네트워크(CDN)를 사용하여 이미지와 비디오의 로딩 속도를 개선했습니다.

### 🚨 FID 개선

- `JavaScript 최적화`:

  - `불필요한 라이브러리`나 `코드 분할`을 통해 초기 로딩 시 필요한 `JavaScript의 양을 줄였습니다.`
  - `React.memo`와 `useCallback`을 사용하여 컴포넌트의 리렌더링을 최소화했습니다.
  - `서버 사이드 렌더링(SSR)`: 페이지 초기 로딩 시 서버에서 HTML을 렌더링해 전송하면 브라우저가 초기 화면을 더 빠르게 렌더링할 수 있어 FID에 긍정적인 영향을 줍니다.

- `비동기 로딩`:
  - `defer 속성을 사용`하여 외부 스크립트를 비동기적으로 로드하고, 초기 렌더링에 영향을 주지 않도록 했습니다.
- `CSS 최적화`

  - `필요한 CSS만 로딩`: 모든 CSS 파일을 한 번에 로딩하는 대신, 중요한 스타일만 우선 로드하고 나머지는 비동기 로딩을 사용합니다. 이를 위해 `CSS를 모듈화`하거나, `Critical CSS 기법`을 활용할 수 있습니다.
  - `중복 및 비사용 CSS 제거`: 애플리케이션에서 사용하지 않는 CSS 규칙을 삭제하고, 중복된 스타일을 정리하여 CSS 렌더링에 필요한 시간을 줄입니다.

- 애니메이션 최적화
  - `CSS 애니메이션과 GPU 가속 활용`: 애니메이션을 자주 사용하는 경우, CSS로 작성하고 `GPU 가속이 가능한 속성(예: transform, opacity)을 사용하는 것`이 좋습니다. `복잡한 애니메이션으로 인해 메인 스레드가 차단되면 FID가 높아질 수 있습니다.`
  - `JS 기반 애니메이션 피하기`: JavaScript로 애니메이션을 구현하면 메인 스레드에서 처리되므로 사용자 상호작용이 느려질 수 있습니다. 애니메이션은 가능하면 CSS로 구현하는 것이 효율적입니다.

### 🚨 CLS 개선

- `고정된 크기 설정`: 이미지와 비디오에 대해 `고정된 너비와 높이를 설정`하여 레이아웃 변경을 방지했습니다.

  ```
  <img src="image.jpg" width="600" height="400" alt="Description" />
  ```

- `글꼴 로딩 최적화`: 사용자 정의 글꼴을 사용하면서도 `font-display: swap` 속성을 추가하여 페이지 로딩 시 글꼴 변경으로인한 레이아웃 이동을 줄였습니다.
- `광고 공간 예약`: 광고를 포함할 경우, 광고의 위치와 크기를 미리 예약하여 레이아웃 이동을 방지했습니다.

# ✨웹 애플리케이션의 성능 최적화를 위해 브라우저의 요청 개수를 줄이는 방법들과, 이러한 방법이 로딩 성능에 어떤 영향을 미치는지 설명해주세요.

- 웹 애플리케이션 성능 최적화에서 중요한 한 요소는 **브라우저의 요청 개수를 줄이는 것**입니다.

- 이 방법을 통해 초기 로딩 속도를 크게 개선하고, 사용자 경험을 향상시킬 수 있습니다. 다음은 브라우저 요청을 줄이기 위한 주요 기법과 각 기법이 로딩 성능 및 유지보수성에 미치는 영향입니다.

---

### 1. 파일 병합 (CSS/JavaScript 파일 결합)

다수의 CSS 또는 JavaScript 파일을 하나의 파일로 병합하여 요청 횟수를 줄입니다. 특히, HTTP/1.1 프로토콜에서 요청 수가 줄어들면 병목 현상이 줄어들고 전체 로딩 시간이 단축됩니다.

- **로딩 성능에 미치는 영향**: 요청 수가 줄어들어 로딩 성능이 개선됩니다. 초기 로딩 시 대용량 파일 하나로 병합되므로 병목이 적어집니다.
- **유지보수성**: 병합된 파일은 수정 시 모든 내용을 다시 빌드해야 하는 번거로움이 있습니다. 규모가 큰 프로젝트에서 유지보수성이 떨어질 수 있습니다.

### 2. 이미지 스프라이트

여러 아이콘이나 `작은 이미지를 하나의 이미지 스프라이트로 병합`한 후, CSS로 해당 영역을 `클리핑`하여 필요한 부분만 화면에 표시하는 기법입니다. 주로 아이콘과 같은 UI 구성 요소에 사용됩니다.

- **로딩 성능에 미치는 영향**: 이미지 요청을 줄여 로딩 속도가 빨라집니다.
- **유지보수성**: 이미지 스프라이트에 새로운 아이콘을 추가하거나 변경하려면 스프라이트 전체를 수정해야 하므로, 업데이트에 다소 어려움이 있습니다.

### 3. 파일 압축 (Gzip, Brotli 사용)

텍스트 파일(CSS, JavaScript, HTML)을 압축하면 파일 크기를 줄여 네트워크 전송 속도를 높일 수 있습니다. Gzip이나 Brotli와 같은 최신 압축 기법은 웹 서버에서 활성화하여 쉽게 적용할 수 있습니다.

- **로딩 성능에 미치는 영향**: 요청 개수를 줄이지는 않지만, 전송해야 할 데이터의 양을 줄여 로딩 속도에 긍정적인 영향을 미칩니다.
- **유지보수성**: 압축은 자동화되므로 유지보수성에 영향을 미치지 않습니다.

### 4. HTTP/2와 HTTP/3 프로토콜 활용

- HTTP/2는 `다중화(Multiplexing)를 지원`하여 `여러 요청을 한 연결에서 동시에 처리할 수 있게 하여`, 요청 개수를 줄이기보다 **요청의 병목 현상을 최소화**합니다.

- 이로 인해 별도의 병합 없이도 많은 파일을 동시에 로드할 수 있습니다.

- **로딩 성능에 미치는 영향**: 병합 없이도 여러 파일을 병렬로 로드 가능하여 웹 성능이 대폭 개선됩니다.
- **유지보수성**: 각 파일을 독립적으로 관리할 수 있어 유지보수성이 높습니다.

### 5. 콘텐츠 전송 네트워크(CDN) 활용

CDN을 통해 자주 사용되는 파일, 특히 라이브러리 파일(jQuery, Bootstrap 등)을 `캐시`하면, 사용자가 해당 파일을 다른 웹사이트에서도 사용하고 있다면 이미 캐시된 파일을 불러와 빠르게 로드됩니다.

- **로딩 성능에 미치는 영향**: 서버 요청 수를 줄이고, 전송 거리를 단축하여 로딩 성능을 높입니다.
- **유지보수성**: 공용 라이브러리의 버전 관리 및 업데이트에 신경을 써야 하므로 약간의 관리 필요성이 있습니다.

### 6. Lazy Loading (지연 로딩)

필요할 때만 리소스를 요청하는 기법으로, 특히 이미지나 동영상과 같은 대용량 리소스를 사용자 스크롤에 따라 로드합니다. 초기 요청 수가 줄어들어 첫 화면 로딩 속도가 크게 개선됩니다.

- **로딩 성능에 미치는 영향**: 초기 로딩 시간은 줄지만, 전체적인 페이지 로딩 완료 시간은 사용자의 스크롤 동작에 따라 길어질 수 있습니다.
- **유지보수성**: 주로 프론트엔드 단에서 구현되며, 코드가 복잡해질 수 있으나 큰 유지보수 부담은 없습니다.

# ✨FID랑 TTI의 차이점은?

- **FID**는 사용자가 **첫 클릭 시 얼마나 빠르게 반응**하는지를 나타내는 초기 지연 시간에 중점을 두고, **TTI**는 **전체 페이지가 모든 상호작용에 반응할 준비가 완료되는 시간**을 측정합니다.
- 두 지표는 **초기 반응성(FID)**과 **완전한 상호작용성(TTI)**을 구분하여 평가하며, 이 두 지표를 모두 최적화하면 사용자에게 매끄러운 경험을 제공할 수 있습니다.

### FID와 TTI의 차이점

| 지표            | FID (First Input Delay)                                                                   | TTI (Time to Interactive)                                                      |
| --------------- | ----------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| **정의**        | 사용자가 처음으로 페이지와 상호작용(예: 클릭) 시, 브라우저가 반응하는 데 걸리는 지연 시간 | 페이지가 모든 중요한 작업을 마치고 **완전히 상호작용 가능한 상태**가 되는 시점 |
| **측정 대상**   | **첫 번째 사용자 상호작용 지연 시간**만 측정                                              | **전체 페이지가 상호작용 가능한 상태**에 도달하는 시간                         |
| **중요성**      | 사용자가 즉각적인 반응을 기대할 때 **빠른 첫 반응성**을 보장                              | 페이지가 **사용자 요청에 부드럽게 반응할 준비가 완료**되었는지 측정            |
| **측정 범위**   | 첫 상호작용 시점부터 브라우저가 반응하는 시점까지                                         | 초기 로딩 후 모든 JavaScript가 준비되어 **차단이 없어진 시점**                 |
| **대표적 예시** | 사용자가 첫 클릭 시 반응이 없는 경우(버튼 클릭 후 지연)                                   | 전체 페이지가 로딩되었지만, 특정 요소 클릭 시 지연되는 경우                    |

- **FID**는 **초기 상호작용 시의 반응 속도**를 측정하기 때문에, 사용자가 페이지에 진입했을 때 **가장 처음으로 경험하는 상호작용성**에 집중합니다.
- **TTI**는 페이지가 **완전하게 상호작용 가능한 상태가 되기까지의 시간**을 측정합니다. 즉, 페이지 로딩이 완료되어 어느 버튼이나 링크를 클릭해도 반응할 준비가 되었는지 확인합니다.

---

### FID와 TTI의 최적화 중점

- **FID 최적화**는 초기 반응성을 개선하기 위해, JavaScript의 초기 로딩 및 실행 시간을 줄이고, 불필요한 대기 시간을 최소화하는 데 중점을 둡니다.
- **TTI 최적화**는 페이지 전체가 상호작용 가능해지기까지의 시간을 줄이는 데 초점을 맞추며, **코드 스플리팅**, **Lazy Loading**, **Web Worker**를 사용해 브라우저 메인 스레드의 부하를 줄이는 방식이 주로 사용됩니다.
