# Server Components의 개념을 설명해주세요.

React의 Server Components는 서버에서 렌더링되는 컴포넌트로, 클라이언트 측에서 JavaScript를 실행하지 않고도 UI를 생성할 수 있는 기능입니다.

이를 통해 웹 애플리케이션의 성능을 개선하고, 사용자 경험을 최적화할 수 있습니다.

1. 서버 렌더링: Server Components는 서버에서 HTML을 생성하고, 클라이언트에 전달합니다. 클라이언트는 이 HTML을 받아서 DOM에 삽입합니다.
2. 데이터 가져오기: Server Components는 서버에서 직접 데이터에 접근할 수 있어, API 호출이나 데이터베이스 쿼리를 쉽게 처리할 수 있습니다.
3. 상태 관리: 클라이언트에서의 상태 관리가 필요 없거나 줄어들며, 필요한 데이터만 클라이언트로 전송됩니다.

## Client Components와의 비교

### 이점

1. 성능 최적화: 초기 로드 시 서버에서 렌더링된 HTML을 받아오기 때문에, 클라이언트에서의 렌더링 비용이 줄어듭니다.
2. SEO 향상: 서버에서 렌더링된 콘텐츠는 검색 엔진 크롤러에 의해 쉽게 인식될 수 있어 SEO에 유리합니다.
3. 더 적은 JavaScript: 클라이언트에서 실행되는 JavaScript 코드가 줄어들어, 번들 크기가 작아지고 로딩 시간이 단축됩니다.
4. 간편한 데이터 처리: 서버에서 직접 데이터에 접근할 수 있어, 클라이언트와 서버 간의 데이터 전송을 줄일 수 있습니다.

### 단점

1. 인터랙티브한 기능 제한: Server Components는 클라이언트에서 상태를 유지하거나 사용자와의 상호작용을 처리하기 어렵습니다. 따라서 복잡한 UI에는 적합하지 않을 수 있습니다.
2. 재사용성 문제: Server Components는 클라이언트에서 사용할 수 없으므로, 기존의 Client Components와의 호환성 문제가 발생할 수 있습니다.
3. 서버에 의존: 서버의 성능에 따라 렌더링 속도가 영향을 받을 수 있습니다.

# Server Components를 사용하여 React 애플리케이션의 성능을 최적화하는 방법을 설명해주세요.

1. 최소한의 클라이언트 코드: Server Components를 사용하여 클라이언트에서 필요한 부분만 Client Components로 만들고, 나머지는 서버에서 처리하도록 설계합니다.
2. 데이터 페칭 최적화: 서버에서 필요한 데이터를 미리 가져와서 렌더링하는 방식으로, 클라이언트에서의 추가적인 API 호출을 줄일 수 있습니다.
3. 정적 사이트 생성: 정적 콘텐츠는 미리 렌더링하여 서버에서 제공함으로써 로드 시간을 단축할 수 있습니다.

## 제약 사항 및 고려해야 할 점

1. 상태 관리: 클라이언트에서의 상태 관리가 필요할 경우, Client Components를 적절히 활용해야 합니다.
2. 서버 리소스: 서버에서 모든 요청을 처리해야 하므로, 서버의 성능과 리소스 관리가 중요합니다.
3. 개발 복잡성: Server Components와 Client Components의 혼합 사용은 코드 구조를 복잡하게 만들 수 있으므로, 설계 시 주의가 필요합니다.

<hr/>

# 서버컴포넌트의 탄생 과정

### 서버 사이드 렌더링의 한계

아래 문제는 리액트가 클라이언트 중심으로 돌아가기 때문에 발생하는 문제들이다.

결국 서버 사이드 렌더링, 클라이언트 사이드 렌더링은 모두 아래 문제를 해결하기에 조금씩 아쉬움이 있다.

서버사이드 렌더링은 정정 콘텐츠를 빠르게 제공하고, 서버에 있는 데이터를 손쉽게 제공할 수 있는 반면

사용자 인터렉션에 따른 다양한 사용자 경험을 제공하기에 어렵다.

클라이언트 사이드 렌더링은 사용자의 인터렉션에 따라 다양한 것들을 제공할 수 있지만 서버에 비해 느리고, 데이터를 가져오는 것도 어렵다.

이러한 두 구조의 장점을 모두 취하고자 하는 것이 서버 컴포넌트이다.

### 🚨자바스크립트 번들크기가 0인 컴포넌트를 만들 수 없다.

타사 라이브러리를 사용할 때 클라이언트인 브라우저에서 해당 `라이브러리를 다운할 뿐만 아니라 실행까지 거쳐야 한다.`

만약 컴포넌트를 서버에서만 렌더링하고, 클라이언트는 결과만 받는다면 어떨까?

즉 라이브러리는 서버에서만 가지고 있고, 클라이언트는 라이브러리를 실행한 결과와 렌더링 결과물만 클라이언트에 제공하는 것이다.

### 🚨백엔드 리소스에 대한 직접적인 접근이 불가능하다.

`백엔드 데이터에 접근하려면 REST API와 같은 방법이 일반적`인데, 이 방법은 편리하지만 `백엔드에서 항상 클라이언트가 접근하기 위한 방법을 마련해야한다는 불편함`이 있다.

직접 백엔드 데이터를 가져온다면 이러한 수고로움을 줄일 수 있다.

### 🚨자동 코드 분할이 불가능하다.

일반적으로 리액트에서는 `lazy를 사용`해왔다.

하지만 이 방법은 일일이 lazy로 감싸야 한다.

개발자는 항상 코드 분할을 해도 되는 컴포넌트인지를 유념하고 개발해야하기 때문에 이를 누락하는 경우가 발생할 수 있다.

또한 컴포넌트가 호출되고, if문을 판단하기 전까지 어떤 지연 로딩한 컴포넌트를 불러올지 결정할 수 없다.이는 지연 로딩으로 인한 성능 이점을 상쇄해 버리는 결과를 만든다.

### 🚨연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어렵다.

하나의 요청으로 컴포넌트가 렌더링되고, 또 그 컴포넌트의 렌더링 결과로 또 다른 컴포넌트가 렌더링되는 시나리오를 상상해보자

이 시나리오는 최초 컴포넌트의 요청과 렌더링이 끝나기 전까지 하위 컴포넌트의 요청과 렌더링이 끝나지 않는다는 큰 단점이 있다.

또한 그만큼 서버에 요청하는 횟수도 증가한다.

그리고 부모 컴포넌트의 요청과 렌더링이 결정되기 전까지 그 부모 컴포넌트의 결과물에 의존하는 컴포넌트들의 서버 요청이 지연되고, 아직 렌더링될 준비가 되지 않았음을 나타내는 불필요한 렌더링까지 발생한다.

이러한 작업을 서버에서 모두 수행하면 어떨까?

데이터를 불러오고, 컴포넌트를 렌더링하는 것이 모두 서버에서 이루어진다면 해결 가능하다.

# 서버컴포넌트가 동작하는 방법

1. 서버가 렌더링 요청을 받는다.

2. 서버는 받은 요청에 따라 컴포넌트를 JSON으로 직렬화한다. 이때 서버에서 렌더링할 수 있는 것은 직렬화해서 내보내고, 클라이언트 컴포넌트로 표시된 부분은 해당 공간을 placeholder 형식으로 비워두고 나타낸다.

3. 브라우저는 이후 이 결과물을 받아서 역직렬화한 다음 렌더링을 수행한다.

4. 브라우저가 리액트 컴포넌트 트리를 구성한다.

- 이때 `스트리밍 형태로 정보를 보내`는데 클라이언트가 `줄 단위로 JSON을 읽고 컴포넌트를 렌더링`할 수 있어 브라우저에서는 `되도록 빨리 사용자에게 결과물을 보여줄 수 있다.`
- 컴포넌트들이 하나의 번들러 작업에 포함되어 있지 않고, `각 컴포넌트 별로 번들링이 별개`로 되어있어 컴포넌트를 지연해서 받거나 따로 받는 등의 작업이 가능해졌다.
- 결과물이 HTML이 아닌 JSON형태로 보내진 것은 HTML을 그리는 작업외에도 해야할 일을 `단순한 JSON으로 받아서 리액트 컴포넌트 트리의 구성을 최대한 빠르게 할 수 있도록` 도와준다.
