# ✨리액트의 렌더링 프로세스에 대해서 설명해주세요

렌더페이즈와 커밋페이즈를 거쳐서 화면에 UI를 렌더링합니다.

렌더페이즈는 `컴포넌트를 계산하고 업데이트 사항을 파악하는 단계`입니다.

커밋페이즈는 `변경사항을 실제 DOM에 반영하는 단계`입니다.

## 🔁꼬리질문

### 🤔렌더페이즈와 커밋페이즈에 대해서 더 자세하게(예를 들어서) 설명해줄 수 있나요?

[출처](https://www.youtube.com/watch?v=N7qlk_GQRJU)

### 렌더페이즈

렌더 페이즈에서는먼저 컴포넌트를 호출해서 `React Element`라는 객체 값을 반환합니다.

그리고 `ReactElement`들을 모아서 `VirtualDOM`을 생성합니다.

<img src="https://github.com/99sStudy/CS-Interview-Master/assets/90139306/a6ed27a0-1114-407b-a033-ebcc0c206a2f
" widtt="100" height="300" />

### 커밋 페이즈

그리고 커밋페이즈에서는
렌더 페이즈에서 계산한 결과를 가지고 실제 DOM에 반영시킵니다.

그리고 브라우저에서는 DOM이 변경된 것을 감지하고,
렌더트리를 다시 만들고, 레이아웃을 다시 잡고, 페인팅을 다시합니다.

<img src="https://github.com/99sStudy/CS-Interview-Master/assets/90139306/174acb21-a552-41d3-a3c6-fbe887d0a2ca" widtt="100" height="300" />

### 리-렌더링 시

만약 업데이트 발생시 `렌더페이즈`부터 다시 실행됩니다.

컴포넌트를 다시 호출하고, 변경사항이 반영된 `ReactElement`들을 다시 반환받고, 모두 모아서 새로운 `Virtual DOM`을 만들게 됩니다.

그 다음으로는 이전 렌더링에서 사용된 `Virtual DOM`과 어떤 것들이 달라졌는지 차이점을 비교합니다.

변경점을 찾고 커밋페이즈로 넘어가 이 변화를 실제 DOM에 한번만 수정함으로써 반영하게 됩니다.

<img src="https://github.com/99sStudy/CS-Interview-Master/assets/90139306/ca99a809-6adb-4d32-a1b7-8fdaa53cc4e9" widtt="100" height="300" />

> 두개의 `Virtual DOM`을 비교해서 실제 DOM에 반영하는 과정을 `재조정(Reconciliation)단계`라고 부릅니다.

<img src="https://github.com/99sStudy/CS-Interview-Master/assets/90139306/34ed37a8-02ad-459e-af5d-6c07a826c6e4" widtt="100" height="300" />

> 결과적으로 리액트의 이런 렌더링 방식은
> 두개의 `Virtual DOM`을 비교해서 실제 DOM에 반영하는 과정을 거쳐서 업데이트가 동시에 많이 발생해도 최대한 한번에 모아서 실제 DOM을 딱 한번만 수정할 수 있도록 동작하기 때문에 대부분의 상황에 충분히 빠른 속도로 화면 업데이트를 추상화된 형태로 자동 제공해주는 것입니다.

### 🤔가상 DOM이 무엇인가요?

실제 DOM을 추상화한 개념으로, 변화가 있을 때마다 전체 UI를 실제 DOM에 직접 반영하는 대신, 이 변화를 메모리에 있는 가상 DOM에 먼저 적용합니다.

그런 다음, 실제 DOM과 가상 DOM을 비교하여 실제로 변경된 부분만 실제 DOM에 반영합니다

### 🤔가상 DOM의 장점이 무엇인가요?

가상DOM은 웹페이지가 표시해야할 DOM을 일단 메모리에 저장하고, 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저의 DOM에 반영합니다.

이렇게 DOM계산을 브라우저가 아닌 메모리에서 계산하는 과정을 한 번 거치게 된다면 `실제로는 여러번 발생했을 렌더링 과정을 최소화`할 수 있고, `브라우저와 개발자의 부담`을 덜 수 있습니다.

### 🤔ReactElement는 무엇인가요?

`ReactElement`는 컴포넌트의 UI에 대한 정보를 모두 포함하고 있는 객체입니다.

<img src="https://github.com/99sStudy/CS-Interview-Master/assets/90139306/330f3abf-032a-4cb8-ae58-27f032e48828" widtt="100" height="300" />

### 🤔재조정 단계가 무엇인가요?

상태 변화가 있을 때 새로운 Virtual DOM을 생성하여 현재 DOM과 비교한 후 차이가 있는 곳을 감지하여 실제 DOM에 적용시켜 주는 과정입니다.

Diffing알고리즘을 쓰는 것으로 알고있습니다. type, key, props 등을 비교합니다.

### 🤔굳이 렌더페이즈와 커밋페이즈와 같은단계를 거쳐서 복잡하게 하는 이유가 뭔가요?

결과적으로 DOM 수정을 최소화하기 위해서 입니다.
업데이트가 발생했을 때 모두 모아서 최소한의 횟수로 DOM을 수정시켜주기 위해서입니다.

그리고 그걸 사용자 모르게 내부적으로 자동화해 주기 위해서입니다.

그럼으로써 대부분의 상황에, 대부분의 업데이트에 충분히 빠른 업데이트를 보장하기 위해서입니다.

### 🤔 그럼 리액트는 항상 빠른 속도를 보장하는 건가요?

그것은 아닙니다.
리액트가 집중하는 부분은 개발자가 크게 신경쓰지 않아도 대부분의 상황에 충분히 빠른 속도로 업데이트를 시키는 것을 포커스하는 것이지 모든 상황에 항상 최고의 속도를 보장하는 업데이트를 구현하는 것은 아닙니다.

왜냐하면 `Virtual DOM`을 생성하고 비교하는데에도 연산이 소요되기 때문입니다.

### 🤔 그럼 브라우저 렌더링 과정(CRP)도 설명해주실 수 있나요?

1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드 한다.
2. 브라우저의 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 DOM 트리를 만든다.
3. CSS파일을 만나면 해당 CSS파일도 다운로드 한다.
4. 브라우저의 렌더링 엔진은 CSS 파일도 파싱해 CSS 노드로 구성된 CSSOM트리를 만든다.
5. 이후 DOM트리와 CSSOM 트리를 합쳐 실제 화면을 그리기 위한 정보인 렌더트리로 변환합니다. 렌더트리에는 시작적으로 보이는 요소들만 포함됩니다.
6. 그후 브라우저는 렌더 트리를 기반으로 각 요소가 위치할 자리를 계산하는 Layout 과정을 거치고, 화면을 그리는 Painting과정을 거칩니다. 중간에 렌더트리에 변화가 생기면 그 변화의 범위에 따라 요소가 그려질 범위를 다시 계산하거나 화면에 그립니다.
7. 이때 앞서 언급한 레이아웃과 페인팅은 여러 레이어로 나뉘어 작업이 이루어지므로(쌓임 맥락) 최종적으로 하나의 결과물로 합치는 과정이 필요합니다. 레이어 간 순서를 따져 하나의 화면으로 합성하는 Composite단계를 거치면 모든 과정이 마무리 됩니다.

### 🤔 쌓임맥락에 대해서 설명해주세요 or 쌓임맥락에 대해서 아시나요?

> `쌓임 맥락(Stacking Context)`은 HTML 요소들의 Z축(페이지에 수직으로 쌓이는 방향) 순서를 정하는 방법입니다. 웹 페이지는 2D 공간으로 보이지만, 요소들은 Z축을 따라 위로 쌓일 수 있습니다. 쌓임 맥락은 어떤 요소가 다른 요소 위에 표시될지를 결정합니다.

`쌓임 맥락`이란 가상의 Z 축을 사용한 HTML 요소의 3차원 개념화이다.
위에서 알 수 있듯 특정 요소의 렌더링 순서는 자신의 z-index 속성 값에 의해 결정된다. 이는 그 요소들이 가진 속성으로 인해 쌓임 맥락이 생성되기 때문이다.

쌓임 맥락은 대표적으로 아래 조건을 만족할 경우 생성된다.

- 문서의 루트 요소 (html)

- position이 absolute , relative 이며, z-index가 auto가 아닌 요소

- position이 fixed , sticky 인 요소

- flexbox 컨테이너의 자식 중 z-index가 auto가 아닌 요소

- grid 컨테이너의 자식 중 z-index가 auto가 아닌 요소

- opacity가 1보다 작은 요소

<br/>
<br/>

## 🔁Deep한 꼬리 질문

### 🤔리액트에서 가상DOM의 렌더링 최적화를 어떻게 하는 것인가요?

가상DOM의 최적화를 가능하게 하는 것이 바로 리액트 파이버입니다.

### 🤔리액트 파이버가 무엇인가요?

파이버는 평범한 객체입니다.

리액트 컴포넌트에 대한 정보를 1:1로 가지고 있습니다.

파이버는 `파이버 재조정자`가 관리하는데 가상 DOM과 실제 DOM을 비교해 변경사항을 수집하며,

만약 이 둘 사이에 차이가 있으면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링 요청을 하는 역할을 합니다.

### 🤔리액트 파이버의 목표는 무엇인가요?

리액트 웹 애플리케이션에서 발생하는 애니메이션, 레이아웃, 사용자 인터랙션에 올바른 결과물을 만드는 반응성 문제를 해결하는 것입니다.

### 🤔리액트 파이버가 하는 일은 무엇인가요?

- 작업을 작은단위로 분할하고 쪼갠 다음, 우선순위를 부여

- 이러한 작업을 일시 중지하거나 다시 시작할 수 있습니다.

- 이전에 했던 작업을 다시 재사용하거나 폐기할 수 있습니다.

- 모든 과정이 비동기로 일어납니다.

### 🤔리액트 재조정 과정이 비동기로 일어난다는 것은 알고 있을까요? 왜 비동기적으로 일어날까요?

과거 리액트의 조정 알고리즘은 `스택 알고리즘`으로 이루어져 있었습니다.

스택이라는 이름에서 알 수 있듯이 스택이 빌 때까지 `동기적`으로 작업이 이루어졌습니다.

하지만 이는 리액트의 `비효율`성으로 이어졌습니다.

그래서 리액트에서는 스택 조정자 대신 `파이버라는 개념을 탄생`시킵니다.

파이버는 `렌더단계`에서 `우선순위를 지정하거나 중지, 폐기 등의 비동기 작업을 수행`합니다.

그리고 `커밋단계`에서는 `실제 DOM에 반영하기위해 작업`하는데 이는 `동기식`으로 일어납니다.

그래서 파이버는 작업들을 작은 단위로 나눠 처리하거나, 애니메이션과 같은 우선순위가 높은 작업을 먼저 처리하거나

우선순위가 낮은 작업은 연기시키는 등 `유연하게 처리`됩니다.

### 🤔리액트의 더블 버퍼링에 대해서 얘기해주세요

먼저 더블 버퍼링이란 사용자에게 미처 다 그리지 못한 모습을 보여주지 않기 위해 보이지 않는 곳에서 다음으로 그려야할 그림을 미리 그린다음, 완성되면 현재상태를 새로운 그림으로 바꾸는 기법을 의미합니다.

리액트는 현재 DOM을 나타내는 `current트리`와 작업중인 상태를 나타내는 `workInProgress트리`로 구성되어있습니다.

이것이 `더블 버퍼링 구조`를 의미합니다.

업데이트가 발생하면 `workInProgress트리`는 새로받은 데이터로 빌드하기 시작합니다.

빌드 작업이 끝나면 다음렌더링에 이 트리를 사용합니다.

그리고 `current트리`는 `workInProgress트리`로 변경됩니다.

### 🤔 setState가 호출되어 리-렌더링되면 파이버트리는 어떻게 되나요?

기존 파이버에서 업데이트된 props를 받아 파이버 내부에서 처리합니다. 즉 재활용합니다.

### 🤔 왜 파이버 트리를 재활용하나요?

일반적인 리액트 애플리케이션을 상상해보면 트리를 비교해서 업데이트 하는 작업이 시도 때도 없이 일어납니다.

이러한 반복적인 재조정 작업 때마다 새롭게 파이버 자바스크립트 객체를 만드는 것은 리소스 낭비라고 볼 수 있습니다.

따라서 가급적 객체를 새롭게 만들기 보다는 기존에 있는 객체를 재활용하기 위해 내부 속성값만 초기화하거나 바꾸는 형태로 업데이트 합니다.
