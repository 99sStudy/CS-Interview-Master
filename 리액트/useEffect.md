## ✨useEffect에 대해서 설명해주세요.

- 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 매커니즘입니다.

- state와 props의 변화속에서 일어나는 렌더링 과정에서 실행되는 부수효과 함수입니다.

첫 번째 인수로는 실행할 부수 효과가 포함된 함수를, 두 번째 인수로는 의존성 배열을 전달합니다.

의존성 배열은 어느 정도의 길이를 가진 배열일 수도, 아무런 값이 없는 빈 배열일 수도 있고, 배열 자체를 넣지 않고 생략할 수도 있습니다.

## 🔁꼬리질문

### 🤔useEffect 클린업 함수의 목적에 대해서 설명해주세요.

클린업함수는 컴포넌트가 사라질 때(unmount 시점), 특정 값이 변경되기 직전(deps update 직전)에 실행할 작업을 지정할 수 있다.

일반적으로 이벤트를 등록하고 지울 때 사용합니다.

보통 언마운트에 클린업 함수가 실행된다고 알고 있는데 조금 차이가 있습니다.

클린업 함수는 언마운트라기보다는 함수형 컴포넌트가 리렌더링됐을 때 의존성 변화가 있었을 당시 이전의 값을 기준으로 실행되는 말 그대로 이전 상태를 청소해주는 개념입니다.

### 🤔useEffect의 의존성 배열에 대해서 설명해주세요.

의존성 배열은 useEffect 훅에 입력하는 두 번째 매개변수입니다.

의존성 배열의 내용이 변경되었을 경우 부수 효과 함수가 실행됩니다.

빈 배열을 둔다면 useEffect가 비교할 의존성이 없다고 판단해 최초 렌더링 직후에 실행된 다음부터는 더이상 실행되지 않습니다.아무런 값을 넘겨주지 않는다면 이때는 의존성을 비교할 필요 없이 렌더링할 때마다 실행이 필요하다고 판단해 렌더링이 발생할 때마다 실행됩니다.

### 🤔의존성 배열이 없는 상황에서는 렌더링 될 때마다 실행된다고 하셨는데 그럼 useEffect없이 써도 되지않나요?

1. 서버사이드 렌더링 관점에서 useEffect는 클라이언트 사이드에서 실행되는 것을 보장해줍니다.
   그래서 useEffect 내부에서는 window 객체의 접근에 의존하는 코드를 사용해도 됩니다.

2. useEffect는 컴포넌트 렌더링의 사이드 이펙트, 즉 컴포넌트 렌더링이 완료된 이후에 실행됩니다.

하지만 직접 실행하는 것은 컴포넌트가 렌더링 되는 도중에 실행됩니다. 이 작업은 함수형 컴포넌트의 반환을 지연시키는 행위입니다. 즉 무거운 작업일 경우에는 렌더링을 방해하므로 성능에 악영향을 미칠 수 있습니다.

### 🤔useEffect를 자바스크립트로 구현한다면 어떻게 하실건가요? (로직을 말로 설명)

```
function useEffect(callback, dependencies) {
  const _index = currentStateIndex;
  // 현재 위치에 저장되어 있는 값이 기존의 dependency이다
  // 최초 실행 시에는 이 값은 undefined일 것이다
  const oldDependencies = states[_index];

  // useEffect 최초 실행 시에는 무조건 callback을 실행하므로 default 값은 true로 설정
  let hasChanged = true;

  // oldDependencies가 존재한다면 현재 받은 dependencies와 비교
  if (oldDependencies) {
    // Array.some 함수를 사용하여 조건을 만족하는 값이 존재하는지 확인
    hasChanged = dependencies.some(
      // 조건: 하나라도 동일하지 않은 값이 있는지
      (dep, i) => !Object.is(dep, oldDependencies[i])
    );
  }

  // 최초 실행, 또는 dependencies 중 변경된 값이 있다면 callback 실행
  if (hasChanged) {
    callback();
    // 현재의 dependency를 다시 현재 위치에 저장
    states[_index] = dependencies;
  }

  currentStateIndex++;
}
```

1. 여러개의 useEffect를 관리하기 위한 배열과 index를 전역에 선언한다.2. useEffect는 매개변수로 callback과 dependencies를 받는다.,3. 클로저를 통해 index를 가둔다.

2. 이전 훅의 정보가 있는지 index로 배열을 확인한다.

3. 이전 훅 정보가 있다면 이전 훅 정보의 dependencies값과 현재 dependencies의 값을 Object.is를 이용해 얕은 비교를 수행해 변경이 일어났는지 true/false를 반환하고, 이전 훅 정보가 없다면 최초 실행이므로 변경이 일어난 것으로 간주해 true를 반환한다.

4. 변경이 일어났다면 매개변수로 받아온 callback함수를 실행한다.

5. 현재 dependencies를 다시 useEffect를 관리하는 배열에 클로저로 가둔 index로 저장한다.

6. 다음 훅이 생성될 때를 대비해 index를 +1 해준다.

### 🤔useEffect를 사용할 때 주의할 점에 대해서 아시는대로 말씀해주세요.

#### 👀 1. useEffect 내부에서 사용한는 값 중 의존성 배열에 포함되어 있지 않은 값이 있을때 eslint 경고를 주석으로 무시하는 경우가 있습니다.

대부분의 경우 컴포넌트를 마운트하는 시점에만 무언가를 하고 싶다는 의도로 빈 배열을 의존성 배열로 사용하는데

이는 클래스형 컴포넌트 생명주기에 기반한 접근법으로 가급적이면 사용해서는 안됩니다.

useEffect는 반드시 의존성 배열로 전달한 값의 변경에 의해 실행돼야 하는 훅입니다.

만약 그렇지 않다면 useEffect의 사이드 이펙트가 실제로 관찰해서 실행돼야하는 값과는 별개로 작동한다는 것을 의미합니다.

해결방법은 의존성 배열로 정말 빈배열을 사용해야되는지 고민하고 검토해야합니다. 정말 마운트 됐을 시점에만 필요하다면 useEffect의 부수효과가 실행될 위치를 바꿔야합니다.

예를들어 부모컴포넌트에서 실행시키는 것으로 해결할 수 있습니다.

이는 빈 배열이 아닐 때도 마찬가지 입니다.

#### 👀 2. useEffect는 익명함수말고 되도록이면 기명함수를 사용하는 것입니다.

우리가 변수에 적절한 이름을 붙이는 이유는 해당 변수가 왜 만들어졌는지 파악하기 위함입니다.

useEffect도 마찬가지로 적절한 이름을 붙이면 해당 useEffect의 목적을 파악하기 쉬워집니다.

#### 👀 3. useEffect의 사이드 이펙트를 크게 만들지 않는 것이 좋습니다.

렌더링 이후에 실행되기 때문에 렌더링 작업에는 영향이 적지만 여전히 자바스크립트 실행 성능에는 악영향을 미칩니다.

가능한 간결하고 가볍게 유지하는 것이 좋습니다.

#### 👀 4. 불필요한 외부 함수를 만들지 않는 것이 좋습니다.

useEffect가 실행하는 콜백 또한 불필요하게 존재해서는 안된다.

예를 들어 useEffect내부의 사이드 이펙트에서 실행되는 함수가 외부에 선언되어있다면 불필요한 의존성 배열과 무한루프를 방지하기 위해 useCallback을 사용해야할 수도 있습니다.

useEffect 내부에서 사용할 사이드 이펙트라면 내부에서 정의해서 사용하는 편이 좋습니다.

### 🤔useEffect의 콜백 인수로 비동기 함수를 넣을 수 있나요? 넣을 수 없다면 이유가 무엇인가요?

useEffect의 인수로 비동기 함수는 state의 `경쟁상태`를 야기할 수 있고, 클린업 함수의 실행순서도 보장할 수 없기 때문에 개발자의 편의를 위해 useEffect에서 비동기 함수를 인수로 받지 않습니다.

useEffect에 async 함수를 넘겨주면 에러가 발생합니다.

만약 useEffect 내부에서 비동기 로직의 결과에 따라 state를 업데이트하는 로직이 있다고 했을 때

극단적인 예제로 이전 state 기반의 응답이 10초가 걸리고, 이후 바뀐 state 기반의 응답이 1초 뒤에 왔다면

이전 state 기반으로 결과가 나와버리는 경우가 생겨버립니다.

이러한 문제를 `useEffect 경쟁상태`라고 합니다.

useEffect내에서 비동기함수를 실행하려면 비동기함수를 인수로 지정하지말고, 내부에서 비동기 함수를 선언해 실행하면 됩니다.

하지만 useEffect 내부에 비동기 함수가 존재하게 되면 비동기 함수가 생성되고 실행되는 것을 반복하므로 클린업함수에서 이전 비동기 함수에 대한 처리를 추가하는 것이 좋습니다.
