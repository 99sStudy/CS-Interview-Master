# ✨React-Query란 무엇인가요?

React Query는 `서버 상태 관리를 매우 효율적으로 처리하는 라이브러리`로, `클라이언트 애플리케이션이 서버와의 데이터 통신을 간단하고 안정적으로 관리`할 수 있게 합니다.

이를 통해 클라이언트와 서버 상태를 통합적으로 관리할 수 있습니다.

## React-Query를 사용하는 주요 이점은 무엇인가요?

1. **자동 데이터 페칭 및 캐싱**

   - React Query는 서버에서 데이터를 가져올 때, 이를 캐싱하여 애플리케이션의 성능을 크게 향상시킵니다.

   - 특히, 동일한 쿼리를 반복적으로 요청할 때 캐시된 데이터를 반환하여 불필요한 네트워크 요청을 줄입니다.

2. **데이터 동기화 및 실시간 업데이트**

   - 서버 데이터가 변경되면 클라이언트에 이를 즉시 반영할 수 있어 실시간 데이터를 유지하기 용이합니다.
   - 예를 들어, 새로운 데이터가 생성되거나 수정된 경우 자동으로 캐시를 업데이트하여 최신 상태를 유지할 수 있습니다.

3. **자동 리페치 (Refetch)와 Stale-While-Revalidate**  
   데이터를 일정 시간 후 자동으로 리페치하여 'Stale' 상태를 관리할 수 있습니다. 이는 데이터가 변경될 가능성이 높은 경우 매우 유용하며, 사용자 경험을 해치지 않으면서 최신 상태를 유지합니다.

4. **효율적인 에러 핸들링 및 재시도 기능**

   - 서버 요청 실패 시 자동으로 재시도를 수행할 수 있는 기능이 내장되어 있어, 네트워크 장애나 서버 오류가 발생했을 때 클라이언트가 이를 관리하기 편리합니다.
   - 이를 통해 보다 안정적인 서버 상태 관리를 수행할 수 있습니다.

5. **로딩, 에러, 성공 상태 관리의 단순화**  
   `isLoading`, `isError`, `isSuccess` 등의 상태를 내장하여 데이터 요청의 다양한 상태를 직관적으로 관리할 수 있게 합니다. 이는 복잡한 비동기 로직을 단순화하며, 사용자 경험 개선에도 크게 기여합니다.

### 클라이언트와 서버 상태를 통합적으로 관리하는 방법

React Query를 활용하면 클라이언트 상태와 서버 상태를 효과적으로 분리하면서도, 이들을 조화롭게 관리할 수 있습니다.

1. **데이터 요청과 UI 상태 관리 분리**

   - 일반적으로 데이터 요청과 관련된 상태(로딩, 에러, 데이터 성공 상태 등)는 React Query가 관리하고, 클라이언트 상태는 `useState`, `useReducer` 등을 통해 관리합니다.

   - 이를 통해 서버 데이터와 로컬 상태를 필요에 따라 개별적으로 관리하면서도, UI가 서버의 상태 변화에 반응하도록 할 수 있습니다.

2. **서버 데이터 업데이트와 캐싱 동기화**

   - React Query는 `mutate` 메서드를 사용하여 데이터를 수정할 수 있습니다.

   - 예를 들어, 서버에 데이터를 수정 요청한 후, 성공적으로 완료되면 관련 쿼리 캐시를 갱신하여 최신 상태를 클라이언트에 즉시 반영할 수 있습니다. 이를 통해 서버와 클라이언트의 데이터 불일치 문제를 해결할 수 있습니다.

3. **비동기 데이터와 클라이언트 로컬 데이터의 조화**

   - 예를 들어, UI 컴포넌트는 `서버에서 데이터를 가져오기 전에 로컬 상태를 사용하여 기본값을 제공`하고, 서버 데이터가 도착하면 로컬 데이터를 서버 데이터로 대체할 수 있습니다.

   - 이는 초기 로딩 중에도 사용자가 원활히 인터페이스를 사용할 수 있게 합니다.

# ✨ReactQuery의 캐싱 전략은 어떻게 하셧나요?

React Query의 캐싱 전략에서 가장 중요한 두 가지 옵션은 `staleTime`과 `gcTime`입니다.

- **`staleTime`**:
  - 데이터를 **신선한(fresh)** 상태로 유지할 시간입니다. 이 시간 동안 데이터를 재요청하지 않고 캐시에서 가져옵니다.
  - 예를 들어, `staleTime`을 5분(5 _ 60 _ 1000 ms)으로 설정하면, 데이터는 5분 동안 신선한 상태로 간주되어 새로 요청하지 않습니다.
  - 이후에는 **stale 상태**로 간주되어 필요한 경우 데이터를 다시 요청하게 됩니다.
- **`gcTime`**:
  - 캐시 데이터를 메모리에 유지할 시간입니다.
  - 이 시간이 지나면 데이터는 **자동으로 삭제**됩니다.
  - 캐시 시간 동안 데이터가 사용되지 않으면 메모리에서 삭제되며, 이후 필요 시 다시 요청하게 됩니다.

> `staleTime`과 `gcTime`의 기본값은 모두 `0`입니다. 즉, 데이터가 항상 오래된 것으로 간주되어 매번 새로 요청하며, 5분 동안만 캐시에 남아 있게 됩니다.

#### 예시

```javascript
const { data } = useQuery("userData", fetchUserData, {
  staleTime: 5 * 60 * 1000, // 5분 동안 데이터를 신선한 상태로 유지
  gcTime: 30 * 60 * 1000, // 30분 동안 캐시에 유지
});
```

## 2. 특정 상황에 맞는 캐싱 전략

캐싱 전략은 애플리케이션의 요구사항에 따라 다르게 설정할 수 있습니다. 대표적인 요구사항에 따라 어떻게 캐싱 전략을 조절할지 설명해 보겠습니다.

### 🤔 1) 자주 갱신되는 데이터 (예: 주식 시세, 실시간 채팅)

- **전략**: `staleTime`을 `낮게 설정`하거나 `0`으로 설정하여 항상 최신 데이터를 가져옵니다.
- **설명**: 실시간 데이터의 경우, 오래된 데이터를 캐싱하는 것은 유효하지 않으므로 데이터를 빠르게 갱신해야 합니다.

  ```javascript
  const { data } = useQuery("stockPrice", fetchStockPrice, {
    staleTime: 0, // 항상 최신 데이터 요청
  });
  ```

### 🤔 2) 자주 변경되지 않는 데이터 (예: 사용자 프로필, 설정 정보)

- **전략**: `staleTime`을 `길게 설정`하여 캐시된 데이터를 최대한 활용합니다.
- **설명**: 데이터가 거의 변하지 않는 경우, `staleTime`을 길게 설정하여 불필요한 API 요청을 최소화할 수 있습니다. 이를 통해 앱 성능을 최적화할 수 있습니다.

  ```javascript
  const { data } = useQuery("userProfile", fetchUserProfile, {
    staleTime: Infinity, // 데이터가 변경되지 않으므로 무한히 신선하게 유지
  });
  ```

### 🤔 3) 특정 사용자 작업 시에만 데이터 갱신이 필요한 경우 (예: 검색 결과)

- **전략**: `enabled` 옵션을 사용하여 `데이터 로딩을 수동으로 관리`합니다.
- **설명**: 데이터 요청이 자주 일어나지 않도록, 조건이 충족될 때만 데이터를 요청하여 캐시할 수 있습니다.

  ```javascript
  const { data } = useQuery("searchResults", fetchSearchResults, {
    enabled: searchTerm !== "", // searchTerm이 있을 때만 데이터를 요청
  });
  ```

### 🤔 4) 백그라운드 데이터 업데이트 (예: 뉴스 피드, 알림)

- **전략**: `일정 간격으로 데이터를 갱신`하는 `refetchInterval`을 설정합니다.
- **설명**: 주기적으로 데이터를 새로 가져와서 최신 상태로 유지하며, 중요한 데이터는 주기적으로 백그라운드에서 업데이트할 수 있습니다.

  ```javascript
  const { data } = useQuery("notifications", fetchNotifications, {
    refetchInterval: 60 * 1000, // 1분 간격으로 데이터 갱신
  });
  ```

## 3. 데이터 갱신 전략: `refetchOnWindowFocus`와 `refetchOnReconnect`

- React Query는 네트워크 상태 변화와 포커스 변화에 따라 데이터를 갱신하는 기능을 제공합니다.

- 이 설정을 통해 사용자가 앱을 떠났다가 돌아올 때 자동으로 데이터를 최신 상태로 갱신할 수 있습니다.

- **`refetchOnWindowFocus`**: 브라우저 창에 앱이 다시 포커스될 때 데이터를 갱신합니다. 기본값은 `true`이며, 사용자가 앱을 다시 볼 때 최신 상태가 보장됩니다.
- **`refetchOnReconnect`**: 네트워크가 다시 연결될 때 데이터를 갱신합니다. 오프라인 모드에서 변경된 데이터를 다시 요청할 때 유용합니다.

```javascript
const { data } = useQuery("userData", fetchUserData, {
  refetchOnWindowFocus: true, // 포커스가 다시 맞춰질 때 데이터 갱신
  refetchOnReconnect: true, // 네트워크 연결 시 데이터 갱신
});
```

### 🤔4. React Query 캐싱 전략 최적화 요약

1. **불필요한 네트워크 요청을 피하기**: 자주 변경되지 않는 데이터는 `staleTime`과 `gcTime`을 설정해 캐시를 최대한 활용합니다.
2. **주기적인 데이터 갱신**: 실시간 또는 중요 데이터는 `refetchInterval`을 사용해 주기적으로 갱신합니다.
3. **조건부 요청**: 특정 상황에서만 데이터를 요청하도록 `enabled` 옵션을 사용해 네트워크 요청을 제어합니다.
4. **포커스와 네트워크 상태 변화에 따른 갱신**: `refetchOnWindowFocus`와 `refetchOnReconnect`를 사용하여 사용자 환경에서 신선한 데이터를 제공할 수 있도록 합니다.

### staleTime과 gcTime의 Best practice

gcTime은 staleTime 보다 항상 커야하는 가?

그렇지 않다.

gcTime을 staleTime보다 크게 설정하는 게 일반적이긴 하지만, 작게 설정한다고 문제가 되는 것은 없다.

다만, 위에서 이야기했던 서버에서 fresh한 데이터를 가져오는 동안엔 캐시된 데이터를 보여준다라는 기능을 사용하지 않게 되는 것이다.

### staleTime을 gcTime보다 길게 설정했다고 가정하면, staleTime만큼의 캐싱을 기대했을 때 원하는 결과를 얻지 못할 것이다. 즉, 두 개의 옵션을 적절하게 설정해줘야 한다.

참고로, TkDodo의 reply에 따르면 `TkDodo는 staleTime을 gcTime보다 작게 설정하는 것이 좋다.는 의견에 동의하지 않는다`고 한다.
예컨대, staleTime이 60분일지라도 `유저가 자주 사용하지 않는 데이터라면 굳이 gcTime을 60분 이상으로 설정하여 메모리를 낭비할 필요가 없다.`
