# ✨사용자 정의 훅과 고차 컴포넌트의 차이점에 대해서 설명해주세요.

둘의 공통점은 리액트에서 재사용할 수 있는 로직을 관리할 수 있는 방법입니다.

## 사용자 정의훅은

- 서로 다른 컴포넌트 내부에서 `같은 로직을 공유하고자 할 때 주로 사용`합니다.
- 리액트에서만 사용할 수 있는 방식입니다.
- 반드시 `use로 시작하는 함수`를 만들어야 합니다.
- 렌더링에 영향을 미치지 못하기 떄문에 `사이드 이펙트가 비교적 제한적`입니다.

### 장단점

- **장점**

  - **간결한 코드**: 중첩 없이 로직을 간결하게 관리할 수 있어 가독성이 높습니다.
  - **독립적 관리**: Custom Hook 내부에서 필요한 상태와 로직을 관리하므로, 컴포넌트 간에 독립적인 상태 관리를 할 수 있습니다.
  - **의존성 관리**: `useEffect`와 `useMemo`의 의존성 배열로 세밀하게 의존성 관리를 할 수 있어 불필요한 리렌더링을 줄일 수 있습니다.
  - **유연한 재사용성**: 다양한 컴포넌트에서 Custom Hook을 호출해 필요한 기능만 가져올 수 있습니다.

- **단점**
  - **Hook 규칙에 따름**: React의 Hook 규칙(use로 시작하고, 컴포넌트 최상단에서 호출 등)을 준수해야 합니다.
  - **초기 학습 곡선**: 기존 HOC나 Render Props 패턴에 익숙한 경우, Custom Hook의 의존성 관리나 상태 업데이트 방식이 다소 생소할 수 있습니다.

## 고차 컴포넌트는

- `컴포넌트 자체의 로직을 재사용하기 위한 방법`입니다.

-- `특정 로직을 하나의 컴포넌트에 캡슐화하고, 여러 컴포넌트에 공통된 기능을 추가할 때 사용`됩니다. 예를 들어, 권한 관리, 로깅, 오류 처리 등 다양한 기능을 추가할 때 사용됩니다.

- 고차함수의 일종으로 자바스크립트 일급 객체, 함수의 특징을 이용하므로 굳이 리액트가 아니더라도 자바스크립트 환경에서 널리 쓰일 수 있습니다.

- React.memo는 고차 컴포넌트입니다.

- `보통 with으로 시작하는 이름을 사용`합니다. 일종의 관습

- 사용자 정의훅에 비해 `렌더링에 영향을 미치는 로직이 존재하므로 예측하기 어렵습니다.`

- 여러개의 고차컴포넌트로 컴포넌트를 감쌀 경우 복잡성이 커집니다.

- 단순하게 useState나 useEffect와 같이 리액트에서 제공하는 훅으로만 공통 로직을 격리할 수 있다면 사용자 정의 훅을 사용하는 것이 좋습니다.

- 함수형 컴포넌트의 반환값, 렌더링의 결과물에 영향을 미치는 공통 로직이라면 고차컴포넌트를 사용하는 것이 좋습니다.

### 장단점

- **장점**

  - **컴포넌트 재사용성**: 동일한 로직을 여러 컴포넌트에 재사용할 수 있어 컴포넌트 간 코드 중복을 줄일 수 있습니다.
  - **단일 책임**: 컴포넌트 자체는 단일 책임 원칙을 따르면서 HOC로 확장할 수 있습니다.

- **단점**
  - **중첩된 구조**: HOC가 여러 개 중첩되면 컴포넌트 트리가 깊어져 가독성이 떨어지고, 디버깅이 어려워집니다.
  - **Props 전달 문제**: 상위 HOC가 하위 컴포넌트로 Props를 전달할 때, 필요하지 않은 Props까지 전달되는 경우가 있어 관리가 복잡해질 수 있습니다.
  - **타입스크립트 사용 시 어려움**: 타입 정의가 복잡해져 코드 유지보수가 어려워질 수 있습니다.

## Render Props패턴은

- `Render Props는 컴포넌트의 자식으로 함수를 전달하여, 자식 함수에서 부모 컴포넌트의 데이터를 사용하도록 하는 패턴`입니다.
- `컴포넌트의 로직을 함수 형태로 전달하여 자식 컴포넌트에서 자유롭게 사용`할 수 있도록 합니다.
- `컴포넌트의 로직을 동적으로 변경하고 싶을 때 사용`합니다.
- 예를 들어, 컴포넌트의 상태를 관리하거나 `화면을 렌더링하는 방식을 조건에 따라 변경할 때 유용`합니다.
- 컴포넌트 간의 상태와 로직을 공유할 수 있습니다.
- 유연한 렌더링이 가능합니다.

### 장단점

- **장점**

  - **동적 렌더링**: 상태나 로직을 자식 함수로 전달해 자식에서 자유롭게 화면을 구성할 수 있습니다.
  - **다양한 시나리오에 활용 가능**: Render Props는 조건에 따라 다양한 UI를 렌더링하는 데 적합합니다.

- **단점**
  - **코드 중첩**: Render Props 패턴을 중첩해서 사용하면 가독성이 떨어질 수 있으며, 컴포넌트 트리가 복잡해질 수 있습니다.
  - **불필요한 렌더링 발생**: 함수를 전달받아 렌더링하는 방식이기 때문에 렌더링 최적화를 따로 고려하지 않으면 성능에 영향을 줄 수 있습니다.
  - **타입스크립트 사용 시 복잡성**: Render Props는 전달하는 Props의 타입을 지정하는 것이 복잡해질 수 있습니다.

---

### Custom Hook, HOC, Render Props 비교 요약

| 패턴             | 개념 및 사용 방식                           | 사용 목적                 | 장점                                                                 | 단점                                                         |
| ---------------- | ------------------------------------------- | ------------------------- | -------------------------------------------------------------------- | ------------------------------------------------------------ |
| **Custom Hook**  | 상태와 로직을 함수로 추출하여 재사용        | 상태와 로직의 재사용      | - 코드가 간결하고 의존성 관리 용이<br> - 다양한 컴포넌트에 적용 가능 | - Hook 규칙을 따라야 함<br> - 초기 학습 곡선이 있을 수 있음  |
| **HOC**          | 컴포넌트를 함수로 래핑하여 새로운 기능 추가 | 컴포넌트 기능 확장        | - 공통 로직 재사용 용이<br> - 단일 책임 컴포넌트 유지 가능           | - 중첩 시 가독성 저하<br> - Props 전달이 복잡해질 수 있음    |
| **Render Props** | 컴포넌트 자식으로 함수 전달해 동적 렌더링   | 렌더링 방식 유연하게 변경 | - 상태나 로직의 동적 변경 용이<br> - 조건에 따른 UI 설정 가능        | - 코드 중첩 가능성<br> - 불필요한 렌더링 및 복잡한 타입 관리 |

---

### 선택 기준 요약

- **상태와 로직의 재사용이 필요**하면 **Custom Hook**을 사용해 **간결하고 유연한 재사용성**을 구현합니다.
- **컴포넌트에 추가 기능**을 덧붙이고자 한다면, 특히 여러 컴포넌트에 동일한 기능이 필요할 때는 **HOC**가 유리합니다.
- 렌더링을 동적으로 변경하고 **조건에 따라 다른 UI를 구성**해야 한다면 **Render Props**가 적합합니다.

## 🔁꼬리질문

### 🤔React.memo는 무엇인가요?

자식 컴포넌트는 부모 컴포넌트가 렌더링되면 props의 변경 여부와 관계없이 렌더링이 발생합니다.

props의 변화가 없음에도 컴포넌트의 렌더링을 방지하기 위해 사용되는 리액트의 고차 컴포넌트입니다.

### 🤔 useMemo를 사용해도 되지않나요?

useMemo를 사용해도 동일하게 구현할 수는 있지만 코드를 작성하고 리뷰하는 입장에서 혼선을 빚을 수 있으므로 목적과 용도가 뚜렷한 memo를 사용하는 편이 좋습니다.

### 🤔고차함수가 무엇인가요?

함수를 인수로 받거나 결과로 반환하는 함수입니다.

### 🤔자바스크립트 일급객체란?

자바스크립트의 `일급 객체`는 `객체가 변수에 할당되거나 함수의 인자로 전달되거나 반환될 수 있는 특성`을 의미합니다.

이는 함수를 일급 객체로 취급하게 하여 고차 함수를 사용할 수 있게 합니다.

이러한 특성 덕분에 자바스크립트는 유연하고 강력한 프로그래밍 패턴을 지원합니다.
