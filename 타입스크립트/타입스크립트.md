## ✨타입스크립트란 무엇인가요?

타입스크립트는 자바스크립트에 타입 시스템을 추가하여, 컴파일 시점에 타입 검사를 수행합니다.

이로 인해 `코드의 안정성`을 높이고, 큰 규모의 애플리케이션을 개발할 때 발생할 수 있는 `버그를 사전에 발견`하고, 개발자 간의 `명확한 커뮤니케이션`을 돕습니다.

## 🔁꼬리질문

### 🤔TypeScript를 사용하는 이유에 대해 설명해주세요.

타입스크립트를 사용하는 가장 큰 이유는 정적 타이핑을 지원한다는 점입니다.

이를 통하여, 런타임 시 타입 에러를 발견하는 것을 막고, 컴파일 단에서 디버깅할 수 있게 됩니다.

1. 정적 타입 검사
   타입스크립트는 정적 타입 검사 기능을 제공하여, 코드 작성 시점에서 타입 오류를 발견할 수 있습니다. 이는 런타임 오류를 줄이고, 코드의 안정성을 높이며, 버그를 조기에 발견하는 데 도움을 줍니다.

2. 가독성 및 유지보수성
   타입스크립트는 타입 정보를 명시적으로 정의할 수 있어, 코드의 가독성이 향상됩니다. 다른 개발자가 코드를 이해하기 쉬워지고, 유지보수가 용이해집니다. 타입이 명확하게 정의되어 있을수록, 코드의 의도를 쉽게 파악할 수 있습니다.

3. IDE 지원
   타입스크립트는 강력한 IDE 지원을 제공합니다. 코드 자동 완성, 리팩토링, 오류 검출 등의 기능이 향상되어 개발자가 더 효율적으로 작업할 수 있습니다. 이러한 기능은 생산성을 높이는 데 큰 도움이 됩니다.

4. 대규모 애플리케이션에 적합
   타입스크립트는 대규모 애플리케이션의 구조와 복잡성을 관리하는 데 유리합니다. 타입을 통해 객체의 형태를 명확히 하고, 코드의 구조를 잘 정의할 수 있어 팀원 간의 협업이 원활해집니다.

5. 자바스크립트와의 호환성
   타입스크립트는 자바스크립트의 상위 집합으로, 기존 자바스크립트 코드를 그대로 사용할 수 있습니다. 따라서 기존 프로젝트에 타입스크립트를 점진적으로 도입할 수 있어 유연하게 사용할 수 있습니다.

6. 모던 자바스크립트 기능 지원
   타입스크립트는 ES6+의 최신 자바스크립트 기능을 지원하여, 최신 문법을 활용한 코드를 작성할 수 있습니다. 또한, 타입스크립트의 타입 시스템은 JavaScript의 동적 타입을 보완하여 더 안전한 코드를 작성할 수 있도록 합니다.

7. 커뮤니티와 생태계
   타입스크립트는 활발한 커뮤니티와 다양한 라이브러리 및 프레임워크의 지원을 받고 있습니다. Angular, React, Vue.js 등 많은 현대 웹 프레임워크가 타입스크립트를 지원하며, 이를 통해 타입스크립트의 장점을 쉽게 활용할 수 있습니다.

### 🤔그냥 자바스크립트로 작성하면 브라우저에서 돌릴 수 있는데 괜히 타입스크립트로 작성하면 트랜스파일링 해야하고, 빌드타임도 늘어나는데 사용하는 이유는?

실제로 빌드타임이 늘어난다.

하지만 프론트엔드 코드는 사용자의 디바이스에서 돌아가기 때문에 최신 안드로이드, IOS, Window PC일 수도 있다.

극단적으로는 갤럭시 s2일 수도 있다.

이 경우 최신 자바스크립트가 동작하지 못할 수도 있다.

이러한 기기들을 지원하기 위해서 폴리필이 존재합니다.

구형 자바스크립트 엔진에서도 돌아갈 수 있도록 최신 자바스크립트 언어를 구형 자바스크립트 언어로 코드를 변환해준다.

즉 프론트엔드 코드는 개발 작업을 마치면 배포 전에 폴리필 작업을 통해 코드를 변환하는 작업을 거치게 된다.

이 과정에서 코드의 양을 줄이는 minification과 같은 작업들도 거치게 된다.

따라서 이 과정들과 함께 타입스크립트를 자바스크립트로 변환하면 되니까 크게 작업성에는 문제가 되지 않습니다.

정리하자면 `코드 작업을 마치고, 브라우저의 호환성과 최적화를 위해서 변환 작업을 거친다면 개발할 때 안정성과 편리함을 위해 타입스크립트를 사용하고, 같이 변환해버리면 됩니다.`

### 🤔Type과 Interface의 차이점에 대해서 아시는대로 설명해주세요

Type은 새로운 타입을 정의할 때 사용되며, 유니온이나 인터섹션과 같은 복잡한 타입을 쉽게 조합할 수 있습니다. 주로 단일 값의 타입을 정의할 때 사용됩니다.

Interface는 `주로 객체의 모양을 정의`하는 데에 사용되며, `확장 가능한 방식(선언 병합)`으로 타입을 구성할 수 있습니다.
인터페이스는 같은 이름으로 여러 번 선언되면 자동으로 합쳐지는 성질이 있어, 확장성이 높습니다.

### 🤔제네릭에 대해서 설명해주세요

제네릭은 `타입을 파라미터처럼 취급`하여, `컴파일 시에 타입을 유연하게 지정`할 수 있게 하는 기능입니다.

이를 통해 코드 재사용성을 높이고, 타입 안정성을 보장하며, 타입 캐스팅에 대한 필요성을 줄일 수 있습니다.

타입을 직접적으로 고정된 값으로 명시하지말고 '변수' 를 통해 언제든지 변할 수 있는 타입을 통해 보다 유연하게 코딩을 할 수 있는 장치가 필요한데 이것이 바로 제네릭(generic) 타이다.

간단하게 말하자면 타입을 변수화 한 것이라고 할 수 있다.

### 🤔타입 캐스팅이 무엇인가요?

타입 캐스팅(type casting)은 특정 변수나 객체의 타입을 컴파일러에게 명시적으로 알려주는 것을 의미합니다.

as 키워드가 타입캐스팅이다.

### 🤔제네릭 유틸리티 타입에 대해서 아시는대로 설명해주세요

타입스크립트는 제네릭을 사용하여 일반적인 타입 변환을 위한 여러 가지 유틸리티 타입을 제공합니다.

#### Partial<T>

-Partial<T> 유틸리티는 타입 T의 모든 속성을 선택적으로 만듭니다. 이를 통해 객체의 부분 집합을 쉽게 표현할 수 있습니다.

#### Required<T>

-반대로 Required<T> 유틸리티는 타입 T의 모든 속성을 필수로 만듭니다.

#### Readonly<T>

-Readonly<T> 유틸리티는 타입 T의 모든 속성을 읽기 전용으로 만듭니다. 이는 불변성을 보장하는 데 유용합니다.

#### Record<K, T>

-Record<K, T> 유틸리티는 키 K와 값 T 타입을 가지는 객체 타입을 생성합니다. 이는 맵의 타입을 정의할 때 유용합니다.

#### Pick<T, K>

-Pick<T, K> 유틸리티는 타입 T에서 속성 K만을 선택하여 구성된 타입을 생성합니다.

#### Omit<T, K>

-Omit<T, K> 유틸리티는 타입 T에서 속성 K를 제외한 타입을 생성합니다.

### 🤔any와 unknown의 차이에 대해서 설명해주세요

- any 타입은 어떠한 타입도 허용하는 타입입니다.
- unknown 타입은 any 타입과 동일하게 모든 값을 허용하지만, 할당된 값이 어떤 타입인지 모르기 때문에 함부로 프로퍼티나 연산을 할 수 없습니다.

unknown 타입을 사용하면 any 타입과는 다르게 프로퍼티 또는 연산을 하는 경우 컴파일러가 체크합니다.

그러므로 문제 되는 코드를 미리 예방할 수 있습니다.

### 🤔never타입은 무엇인가요?

never는 바닥타입이며 타입의 공집합이다.

따라서 undefined 조차도 할당이 불가능하고, 함수의 경우에는 아예 반환이 불가능하다.

### 🤔어떨 때 never를 사용하나요?

함수가 아무것도 반환하지 않을 때 -> never 를 반환타입으로 지정하여 타입추론 예외를 제거한다.

### 🤔타입스크립트의 readonly에 대해서 아시나요?

타입스크립트(TypeScript)에서 readonly는 주로 객체의 속성을 읽기 전용으로 선언할 때 사용됩니다.

인터페이스에서 readonly를 사용하여 속성을 정의할 수 있습니다. 이 경우, `해당 인터페이스를 구현하는 객체는 읽기 전용 속성을 변경할 수 없습니다.`

클래스의 속성을 readonly로 선언하면, 해당 속성은 클래스의 생성자에서만 초기화할 수 있으며, 이후에는 변경할 수 없습니다.

### 🤔클래스의 Public, Private, Protected에 대해 설명해주세요.

public은 어디에서나 접근할 수 있는 값으로, 생략 가능한 default 값입니다.

private은 해당 클래스의 인스턴스에서만 사용할 수 있는 값입니다.

protected는 해당 클래스 혹은 서브 클래스의 인스턴스에서만 접근이 가능한 값입니다.

### 🤔클래스의 Static에 대해 설명해주세요.

static 키워드를 사용하면 정적 변수, 또는 정적 함수를 만들 수 있습니다.

이들은, 인스턴스가 아닌 클래스에 속하는 변수와 함수로, 이들을 호출하기 위해 인스턴스가 필요하지 않습니다. 인스턴스에서 호출할 경우, 에러가 발생합니다.

또한 클래스 자체에 속하기 때문에, 다른 인스턴스들에게 모두 영향을 줄 수 있습니다.

- 단점
  - 전역 상태: 정적 속성을 남용하면 전역 상태를 만들 수 있어 코드의 예측 가능성을 떨어뜨릴 수 있습니다.
  - 유연성 감소: 인스턴스와 관련된 기능을 정적으로 구현하면 다형성을 활용하기 어려울 수 있습니다.

아래에 각 항목에 대한 설명을 추가하고 예시를 제공하겠습니다.

### 타입 추론

타입스크립트는 변수나 함수의 반환값 등에 대해 명시적인 타입이 선언되지 않은 경우, 코드의 문맥을 분석하여 가장 적절한 타입을 자동으로 추론합니다.

- **가장 적절한 타입**: 표현식을 통해 가장 근접한 타입을 추론합니다.
- **문맥상 타이핑**: 코드의 위치(문맥)에 따라 타입을 정의합니다.

```typescript
let num = 42; // 타입스크립트는 num의 타입을 number로 추론합니다.

function add(a: number, b: number) {
  return a + b; // 반환 타입이 number로 추론됩니다.
}

const result = add(num, 10); // result는 number 타입으로 추론됩니다.
```

### 타입 호환

타입 호환성은 특정 타입이 다른 타입과 잘 맞는지를 판단하는 개념입니다. 타입스크립트는 구조적 타입 시스템을 사용하므로, 객체의 속성과 메소드가 일치하면 서로 호환됩니다.

```typescript
interface Animal {
  name: string;
}

interface Dog {
  name: string;
  bark: () => void;
}

const myDog: Dog = {
  name: "Buddy",
  bark: () => console.log("Woof!"),
};

let myAnimal: Animal = myDog; // Dog는 Animal과 호환됩니다.
```

### 타입 가드

타입 가드는 특정 변수의 타입을 좁히는 방법입니다. 조건문을 사용하여 런타임에 변수의 타입을 확인할 수 있습니다.

```typescript
function printLength(value: string | string[]) {
  if (typeof value === "string") {
    console.log(value.length); // value는 string 타입으로 좁혀집니다.
  } else {
    console.log(value.length); // value는 string[] 타입으로 좁혀집니다.
  }
}

printLength("Hello"); // 출력: 5
printLength(["Hello", "World"]); // 출력: 2
```
