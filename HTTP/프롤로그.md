## ✨ MIME란 무엇인가요?

원래 이메일을 통해 전송되는 파일의 형식을 지정하기 위해 개발된 표준이지만, 현재는 웹에서도 광범위하게 사용됩니다. MIME 타입은 파일의 형식을 나타내는 문자열로, 웹 서버와 브라우저가 파일의 내용을 이해하고 적절하게 처리할 수 있도록 합니다.

## ✨ URI와 URL, URN에 대해서 설명해주세요

### URI (Uniform Resource Identifier)

웹 리소스를 식별하는 문자열입니다. URI는 URL과 URN을 포함하는 상위 개념입니다.

- 통합 자원 식별자(Uniform Resource Identifier)는 인터넷에 있는 자원을 어디에 있는지 자원 자체를 식별하는 방법입니다.

### URL (Uniform Resource Locator)

리소스의 위치를 설명하는 URI의 한 형태입니다. 예를 들어, `https://example.com/index.html`은 웹 페이지의 위치를 나타내는 URL입니다.

- 파일식별자(Uniform Resource Locator)는 네트워크 상에서 자원이 어디 있는지 위치를 알려주기 위한 규약입니다.

### URN (Uniform Resource Name)

리소스의 이름을 식별하는 URI의 한 형태로, 위치와 상관없이 리소스를 식별할 수 있습니다. 예를 들어, `urn:isbn:0451450523`은 특정 책의 ISBN을 URN으로 나타낸 것입니다.

## ✨ GET과 POST의 차이점에 대해서 아시나요?

### GET

- URL을 기반으로 데이터를 요구하는 방법입니다.
- URL을 기반으로 하기 때문에 길이 제한(2000자 미만)이 있습니다.
- 성공 시 HTTP 상태코드 200을 반환합니다.
- 캐싱이 가능합니다.
- URL을 기반으로 요청하기 때문에 해당 요청의 파라미터가 브라우저 기록에 남습니다.
- URL을 기반으로 요청하기 때문에 요청할 때 ASCII 문자열만을 보낼 수 있습니다.
- 사용자 이름, 비밀번호 등 민감한 정보를 전달할 때 사용하지 않습니다.

### POST

- URL이 아닌 HTTP 메시지 바디를 통해 데이터를 전달합니다.
- HTTP 메시지 바디를 통해 전달되기 때문에 길이 제한이 없습니다.
- 성공적으로 데이터를 생성할 경우 HTTP 상태코드 201을 반환합니다. (생성하지 않은 경우 200을 반환하기도 합니다.)
- 캐싱이 불가능합니다.
- URL을 기반으로 요청하지 않기 때문에 해당 요청의 파라미터가 브라우저 기록에 남지 않습니다.
- HTTP 메시지 바디로 요청하기 때문에 ASCII 문자열뿐만 아니라 모든 유형의 데이터를 기반으로 요청할 수 있습니다.
- 사용자 이름, 비밀번호 등 민감한 정보를 전달할 때 사용합니다.

## ✨ PUT과 PATCH의 차이점 대해서 아시나요?

### PUT

- 리소스를 완전히 대체합니다.
- 지정된 리소스가 존재하지 않으면 생성합니다.
- 전체 리소스를 갱신할 때 사용됩니다.

### PATCH

- 리소스의 일부를 수정합니다.
- 기존 리소스의 일부분만 업데이트할 때 사용됩니다.
- 더 적은 데이터 전송으로 효율적인 업데이트가 가능합니다.

## ✨ 상태코드의 종류에 대해서 아는대로 설명해주세요

### 1xx (정보)

서버가 요청을 잘 받았으며 해당 프로세스를 계속 이어가며 처리하는 것을 의미합니다.

- 100 : 계속함을 의미합니다.

### 2xx (성공)

서버가 요청을 잘 받았고 이를 기반으로 클라이언트에게 성공적으로 데이터를 보낸 것을 의미합니다.

- 200 OK : 요청이 성공적으로 되었습니다.
- 201 Created : 요청이 성공적이었으며 그 결과로 새로운 리소스가 생성되었습니다.

### 3xx (리다이렉션)

서버가 클라이언트의 요청에 대해 완료를 위해 추가 작업 조치가 필요합니다.

- 301 Moved Permanently : 이 응답코드는 요청한 리소스의 URI가 변경되었음을 의미합니다. 변경된 새로운 URI를 301 상태코드와 함께 주어야 합니다.

### 4xx (클라이언트 오류)

클라이언트가 요청한 페이지를 제공할 수 없거나 클라이언트의 요청이 잘못되어 결과적으로 요청을 처리할 수 없습니다.

- 400 Bad Request : 서버가 클라이언트 요청을 이해할 수 없음을 의미합니다.
- 401 Unauthorized : 클라이언트의 인증이 되지 않음을 의미합니다.
- 404 Not Found : 요청받은 콘텐츠를 찾을 수 없음을 의미합니다.

### 5xx (서버 오류)

서버가 클라이언트의 요청을 처리하지 못하는 상태입니다.

- 500 Internal Server Error : 서버에 오류가 있음을 의미합니다.
- 502 Bad Gateway : 게이트웨이 또는 프록시 서버에 오류가 생겼음을 의미합니다.
- 504 Gateway Timeout : 게이트웨이 또는 프록시 서버가 정해진 Timeout 시간 동안 클라이언트의 요청을 처리하지 못함을 의미합니다.

## ✨ HTTP/1.0과 1.1의 차이에 대해서 아시나요?

### HTTP/1.0

- HTTP/1.0은 수명이 짧은 연결입니다.
- HTTP 요청은 자체 요청에서 완료가 됩니다.
- 각 HTTP 요청당 TCP 핸드셰이크가 발생되며 기본적으로 한 연결당 하나의 요청을 처리하도록 설계되었습니다.
- 한번 연결할 때마다 TCP 연결을 계속해야 하니 RTT가 늘어나는 문제점이 있었습니다.

### HTTP/1.1

- HTTP/1.0의 단점을 보완한 프로토콜입니다.
- Keep-alive 커넥션이 기본 옵션화되었습니다. 가상 호스팅 지원, 프록시 연결 지원을 포함합니다.

  #### 1. Keep-alive default

  - 매번 데이터를 요청할 때마다 TCP를 연결하는게 아닌 한 번 해놓고 계속해서 데이터를 받을 수 있게 만들었습니다.
  - 이는 keep-alive 옵션을 기본 옵션으로 하면서 가능해졌습니다. (Node.js는 5초 동안 유지)
  - HTTP/1.0에서도 keep-alive 옵션이 있었지만 실험적이었고, 기본값이 아니었습니다.

  #### 2. 호스트 헤더를 여러 개 가질 수 있음

  - HTTP/1.0은 서버가 하나의 호스트만 가진다고 가정하기 때문에 HTTP/1.0은 헤더에 호스트를 포함하지 않았습니다.
  - 이 때문에 HTTP/1.0은 하나의 IP에 하나의 호스트만 가질 수 있었습니다.
  - 그러나 서버는 여러 개의 호스트를 가질 수 있으며 이런 유연성을 위해 HTTP/1.1은 헤더에 특정 호스트를 포함할 수 있게 변경되었으며 항상 호스트를 포함해서 요청하도록 바뀌었습니다.

  #### 3. 대역폭 최적화

  - HTTP/1.0의 경우 어떠한 파일을 다운로드 받다가 연결이 끊기면 다시 다운로드 받는

  - HTTP/1.0의 경우 어떠한 파일을 다운로드 받다가 연결이 끊기면 다시 다운로드 받는 것은 불가능 했습니다.

  - 이를 다시 다운로드 받을 수 있게 바뀌었습니다.

ex) HTTP/1.0에서는 10KB 파일을 다운로드 받는다고 했을 때 5KB까지만 받고 다시 다운로드를 받는게 불가능 했다.

하지만 HTTP/1.1에서는 Range:bytes=5000- 라는 헤더를 추가해서 다운로드 재개 요청을 할 수 있게 바뀐 것입니다.

=> HTTP/1.1로 발전했음에도 불구하고 서버요청할 때마다 RTT는 계속 증가하게 됐고, 요청을 줄이기 위해 여러가지 기술들을 도입함

이미지 스프라이트, 코드 압축, Base64 인코딩 기술을 같이 쓰게 됨(현재도 같이 쓰곤한다.)
해당 기술은 RTT를 줄이기 위한 기술이다.

## ✨ HTTP/1.1의 고질적인 문제

HTTP/1.1은 HOL(Head Of Line Blocking)과 무거운 헤더 문제를 가지고 있었으며, 이를 해결하지 못했습니다.

## ✨ HOL이란?

네트워크에서 같은 큐에 있는 패킷이 첫 번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상을 말합니다. 쉽게 설명하면, 나누어진 패킷은 순서를 바꿀 수 없어서 만약 첫 번째 패킷이 다운로드가 엄청 걸리는 파일이라면 이 패킷 때문에 뒤에 있던 패킷들이 지연되는 것입니다.

## ✨ HTTP/2.0의 특징

구글은 HTTP/1.1의 한계를 극복하기 위해 SPDY 프로토콜을 개발하였고, 이후 SPDY를 기반으로 하는 HTTP/2 프로토콜을 개발했습니다.

### 💭 바이너리 포맷 계층

애플리케이션 계층과 전송 계층 사이에 바이너리 포맷 계층을 추가했습니다. HTTP/1.0은 일반 텍스트 메시지를 전송하고 줄바꿈으로 데이터를 나눴다면, HTTP/2.0은 0과 1로 이루어진 바이너리 데이터로 변경되었고, 더 작은 메시지가 프레임으로 캡슐화되어 전송됩니다.

### 💭 멀티플렉싱

단일 TCP 연결의 여러 스트림에서 여러 HTTP 요청과 응답을 비동기적으로 보낼 수 있습니다. 이를 통해 HOL 문제를 해결합니다. HTTP/1.1에서는 병렬 요청을 하려면 다중 TCP 연결을 통해야 했고, 일반적으로는 TCP 연결 하나당 병렬 요청은 불가능했습니다.

HTTP/2.0에서는 리소스를 작은 프레임으로 나누고 이를 스트림으로 전달합니다. 각각의 프레임은 스트림 ID와 해당 청크의 크기를 나타내는 정보를 포함하여 작게 나누어진 데이터가 다운로드되더라도 결과적으로 올바른 순서로 재조립할 수 있게 됩니다.

쉽게 말하면, HTTP/1.1은 요청과 응답이 순차적으로 이루어지기 때문에 앞선 요청이 오래 걸리면 뒤에 있는 요청도 지연됩니다. HTTP/2.0에서는 데이터를 잘게 쪼개서 병렬로 보내며, stream ID와 content-length 정보를 통해 순서가 뒤엉킬 수 있는 문제를 해결합니다.

### 💭 서버 푸시

서버가 리소스를 클라이언트에 푸시할 수 있습니다. 요청된 HTML 파일과 함께 다른 개체를 별도로 보낼 수 있습니다. 예를 들어, 요청한 HTML에 CSS가 포함되어 있다면 별도 요청 없이 CSS를 같이 보낼 수 있습니다.

HTTP/1.1에서는 `<link>` 태그로 적은 CSS 파일은 원래 HTML을 다운로드한 후, HTML에 CSS가 존재하면 다시 CSS 파일을 요청하는 방식이었습니다. HTTP/2.0에서는 HTML을 요청하면 서버가 HTML을 읽고, 안에 CSS 파일이 존재하면 응답할 때 CSS 파일도 같이 응답합니다.

### 💭 헤더 압축

HTTP/1.1에서는 무거운 헤더가 있었지만, HTTP/2.0에서는 이를 허프만 인코딩 압축 방법 등으로 압축합니다. 예를 들어, 같은 서버에서 두 개의 이미지를 전송할 때 중복되는 헤더는 제외하고, 해당 공통 필드로 헤더를 재구성하며 중복되지 않은 헤더값은 허프만 인코딩으로 압축하여 전송합니다.

> **참고**: 허프만 인코딩은 문자열을 문자 단위로 쪼개 빈도수를 세어 빈도가 높은 정보는 적은 비트수를 사용해 표현하고, 빈도가 낮은 정보는 비트 수를 많이 사용하여 전체 데이터 표현에 필요한 비트 양을 줄이는 알고리즘입니다.

### 💭 우선순위

서버에서 원하는 순서대로 우선순위를 정해 리소스를 전달할 수 있습니다.

## ✨ 프록시란 무엇인가요?

프록시(Proxy)는 클라이언트와 서버 사이에 위치하여 요청을 대신 전달하거나 응답을 받아오는 중개 서버입니다.

프록시는 다음과 같은 용도로 사용됩니다

- 보안 강화 (방화벽 역할)
- 캐싱을 통해 성능 향상
- 익명성 보장
- 접근 제어 및 로깅

## ✨ 게이트웨이란 무엇인가요?

게이트웨이(Gateway)는 서로 다른 네트워크 환경이나 프로토콜을 사용하는 시스템 간의 통신을 가능하게 하는 장치 또는 소프트웨어입니다.

흔히 API 게이트웨이, 이메일 게이트웨이, VoIP 게이트웨이 등이 있습니다.

게이트웨이는 다음과 같은 역할을 합니다:

- 프로토콜 변환
- 데이터 형식 변환
- 보안 및 인증
- 로드 밸런싱
