## 🤔불변성을 유지하려면 어떻게 해야하나요?

자바스크립트에서 불변성이란 객체가 생성된 이후 그 상태를 변경할 수 없는 것을 의미합니다.

1. `Object.assign()` 메소드와 `spread 연산자` 이용하기

   - 하지만 객체 내부의 객체가 있다면 얕은복사가 된다..

2. 객체를 불변하게 만들기

   - 객체를 복사할 때 깊은 복사를 해서 새로운 객체를 만들 수 있지만, 아예 객체 자체를 불변하게 만드는 방법이 있습니다.

   - 총 3가지 메소드 `Object.preventExtensions()`, `Object.seal()`, `Object.freeze()`를 통해서 객체의 변경을 막을 수 있습니다.

   1. `Object.preventExtensions()` 메소드

      - `Object.preventExtensions()` 메소드는 이름으로 유추할 수 있듯이, `객체의 확장을 막는 메소드`입니다. 새로운 속성을 추가하려고 시도한다면, TypeError가 발생하거나 조용히 실패하게 됩니다.

   2. Object.seal() 메소드

      - `Object.seal()` 메소드는 `속성의 추가와 속성의 삭제를 둘 다 막는 메소드`입니다. 단, 기존의 속성 값을 `변경하는 것은 가능`합니다.

   3. Object.freeze() 메소드

      - `Object.freeze()`를 메소드는 `속성의 추가, 속성의 삭제, 속성 값 변경을 모두 막는 강력한 메소드`입니다

3. `JSON.parse(JSON.stringify(obj))` 사용(깊은복사 가능)

   - JSON 객체를 `stringify` 메서드를 통해 직렬화(serialize)한 뒤, parse 메서드를 통해 이를 역직렬화(deserialize)하는 방식이다.

   - JSON.`stringify()` 는 객체를 json 문자열로 변환하는데, 이 과정에서 원본 객체와의 참조가 모두 끊어지기 때문에 깊은 복사가 가능해진다.

   - 이후 `JSON.parse()`를 통해 다시 자바스크립트 객체로 만들어주면 복사가 완료된다.

   - 간단한 방법이지만, 객체 내에 함수가 있을 경우 함수를 처리하지 못한다는 단점이 있다.

   - 즉, 간단한 형태의 객체일 때에만 동작한다.

4. 외부 라이브러리 사용 lodash의 `cloneDeep`

   - 가장 안전하고 좋은 방법이다.
   - 외부 라이브러리의 깊은 복사로 불변성을 유지할 수 있다.

   React에서 컴포넌트 상태의 **불변성(immutability)**을 유지하는 것은 매우 중요합니다. 불변성을 유지하지 않으면 리렌더링 최적화가 어려워지고, 예상치 못한 버그가 발생할 가능성이 커집니다. 이에 따라 불변성을 유지하는 방법과 이를 위해 사용할 수 있는 도구와 기법을 알아보겠습니다.

## 🤔 리액트에서 불변성을 유지하는 이유

1. **리렌더링 최적화**

   - React는 상태가 변경되었을 때 리렌더링 여부를 결정하기 위해 `===` 연산을 통해 상태의 변경 여부를 판단합니다.
   - 이때 객체가 불변성을 유지하면 **참조가 변경**되므로 `React가 효율적으로 상태 변화를 감지할 수 있습니다.`
   - 반대로 불변성을 깨고 기존 상태를 직접 수정하면 참조가 변하지 않아 React는 변경된 상태를 인식하지 못할 수 있습니다.
   - 이로 인해 리렌더링이 되지 않거나 불필요한 리렌더링이 발생할 수 있습니다.

2. **디버깅 용이성**

   - 불변성이 깨지면 상태의 예측 가능성이 떨어져서 예상치 못한 버그가 발생할 수 있습니다.
   - 특히 상태가 중첩되어 있는 경우 디버깅이 어려워집니다.
   - 불변성을 유지하면 상태가 변경되는 시점마다 새로운 객체를 생성하게 되어, 변경 전후의 상태를 쉽게 비교할 수 있어 디버깅이 수월해집니다.

3. **함수형 프로그래밍 패러다임에 적합**
   - React는 `함수형 프로그래밍의 원칙`을 따르므로, 불변성을 지키면서 상태를 관리하는 것이 React의 패러다임에 잘 맞습니다.
   - 상태가 불변일 때, 변경이 발생해도 원본 상태가 변하지 않으므로 이전 상태와 새 상태를 안전하게 비교할 수 있습니다.

---

### 불변성을 효율적으로 유지하기 위한 도구와 기법

React에서 불변성을 유지하면서 상태를 업데이트하기 위해 사용할 수 있는 주요 도구와 기법으로는 **스프레드 연산자, Object.assign, immer**가 있습니다.

#### 1. 스프레드 연산자 (`...`)

- 스프레드 연산자는 객체 또는 배열을 얕게 복사(shallow copy)할 때 유용하게 사용됩니다.
- 새로운 배열이나 객체를 생성하고 그 안에 기존 상태를 복사하여 불변성을 유지하면서도 쉽게 업데이트할 수 있습니다.

- **배열 예시**

  ```javascript
  const numbers = [1, 2, 3];
  const newNumbers = [...numbers, 4]; // 기존 배열을 변경하지 않고 새로운 배열 생성
  ```

- **객체 예시**

  ```javascript
  const user = { name: "Alice", age: 25 };
  const updatedUser = { ...user, age: 26 }; // user의 불변성을 유지하면서 age를 업데이트
  ```

- 스프레드 연산자는 단순한 구조에서는 매우 유용하지만, **깊이 중첩된 객체나 배열을 다룰 때는 한계**가 있습니다.
- 중첩된 객체를 `얕은 복사`만 하기 때문에, 중첩된 데이터 구조의 불변성을 지키기에는 다소 불편할 수 있습니다.

#### 2. `Object.assign` 메서드

- `Object.assign`을 사용하면 객체를 병합할 수 있습니다. 이 메서드는 새로운 객체를 생성해 불변성을 유지하면서 특정 프로퍼티를 업데이트하는데 유용합니다.
- 그러나 스프레드 연산자와 마찬가지로 `얕은 복사만 수행`합니다.

- **예시**
  ```javascript
  const user = { name: "Alice", age: 25 };
  const updatedUser = Object.assign({}, user, { age: 26 }); // 새로운 객체를 생성하여 불변성 유지
  ```

`Object.assign`은 스프레드 연산자와 비슷하지만, **ES5 이상의 버전에서 사용**되며 코드가 다소 길어질 수 있어 스프레드 연산자가 선호됩니다.

#### 3. `immer` 라이브러리

- `immer`는 중첩된 데이터 구조에서도 불변성을 쉽게 유지할 수 있도록 도와주는 라이브러리입니다.
- `immer`는 내부에서 불변성을 유지하면서도, `draft` 객체라는 가상의 가변 상태를 생성해 이를 수정하게 합니다.
- 마지막에 이 `draft` 객체를 자동으로 불변 객체로 변환해주기 때문에 중첩된 데이터의 상태를 관리할 때 특히 유용합니다.

- **immer 사용 예시**

  ```javascript
  import produce from "immer";

  const user = { name: "Alice", address: { city: "Seoul", zip: "12345" } };

  const updatedUser = produce(user, (draft) => {
    draft.address.city = "Busan"; // 기존의 깊은 구조에 안전하게 접근하여 변경 가능
  });
  ```

`immer`는 코드의 가독성을 높이면서도, 복잡한 상태 구조를 불변성을 유지하며 관리할 수 있어 중첩된 객체가 있는 경우 매우 유용합니다.

#### 4. `Array.map`과 `Array.filter`를 활용한 불변성 유지

배열을 업데이트할 때 `map`과 `filter` 메서드를 활용하면, 불변성을 지키면서 데이터를 쉽게 변형할 수 있습니다.

- **예시: 항목 추가 및 수정**

  ```javascript
  const todos = [
    { id: 1, text: "Learn React", completed: false },
    { id: 2, text: "Read a book", completed: false },
  ];

  // 새로운 항목 추가
  const newTodo = { id: 3, text: "Write Code", completed: false };
  const updatedTodos = [...todos, newTodo];

  // 특정 항목 수정 (id가 2인 항목의 completed를 true로 변경)
  const toggledTodos = todos.map((todo) =>
    todo.id === 2 ? { ...todo, completed: true } : todo
  );
  ```

이 방식은 **배열의 각 항목을 개별적으로 업데이트**할 수 있어 상태가 복잡해질 때 특히 유용하며, `map`과 `filter`를 사용하여 불변성을 유지하면서도 간단하게 배열을 조작할 수 있습니다.
