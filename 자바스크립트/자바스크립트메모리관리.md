## ✨자바스크립트의 메모리 관리에 대해서 설명해주세요.

객체를 변수에 할당하면 객체는 heap라는 곳에 만들어집니다.
변수는 메모리의 주소를 가리키게 되는데, 메모리 안에 아무것도 없을 경우에는 쓰레기로 간주하고, 청소를 하게 됩니다.

자바스크립트에서 가비지 컬렉션이 발생하는 원리는 가비지 컬렉터라는 기능이 있는데, 이는 자바스크립트 엔진 자체에서 제공해주고, 백그라운드 프로세스에서 동작해줍니다.
대신 이 부분에서 CPU 비용이 발생합니다.

글로벌 변수는 앱이 종료될 때 까지 메모리에 유지되고,
블록 스코프는 블록 스코프의 역할이 끝나면 자동으로 소멸됩니다.
그래서 가급적 글로벌하게 전역 변수를 쓰지 않는 것이 좋습니다.

## 🔁꼬리질문

### 🤔스택 영역과 힙 영역에 대해서 설명해주세요.

#### 스택

스택은 `자바스크립트가 정적 데이터를 저장하는 데 사용하는 자료 구조`입니다.

`정적 데이터`란 `엔진이 컴파일 타임에 크기를 알고 있는 데이터`를 말합니다.

자바스크립트에서는 `원시 값primitive (string, number, bigint, boolean, undefined, symbol, null)`과 객체 및 함수를 가리키는 `참조reference`가 해당합니다.

`크기가 변경되지 않을 것임`을 알고 있으므로, 엔진은 각 값에 대해 `고정된 크기의 메모리를 사전에 할당`합니다.

그리고 이렇게 실행 직전에 메모리를 할당한다는 점에서, 이를 `정적 메모리 할당`이라고 합니다.

이때 값과 전체 스택에 대한 제한은 브라우저에 따라 다르게 구현됩니다.

#### 힙

힙은 `자바스크립트가 객체와 함수를 저장하는 데이터를 저장하는 또 다른 공간`입니다.

스택과 달리, `엔진은 고정된 크기의 메모리를 할당`하지 않습니다. 대신 필요에 따라 더 많은 공간을 할당합니다.

이러한 방식으로 메모리를 할당하는 것을 `동적 메모리 할당`이라고 합니다.

### 🤔가비지컬렉터는 메모리가 여전히 필요한지에 대한 여부를 어떻게 결정하나요?

더 이상 메모리가 사용되지 않는 정확한 순간에 쓰레기를 수집해낼 수 있는 알고리즘은 존재하지 않는다고 합니다.

하지만 일부 알고리즘은 이러한 문제에 대해 훌륭한 근사해를 제시합니다.

가장 많이 사용되는 알고리즘은 `Reference-counting garbage collection`과 `Mark-and-Sweep` 알고리즘입니다.

1. 참조 카운팅 (Reference Counting)
   작동 원리: 각 객체는 참조 카운트를 유지합니다. 이 카운트는 해당 객체를 참조하는 변수의 수를 나타냅니다. 객체가 생성될 때 카운트가 1로 시작하고, 새로운 참조가 생길 때마다 카운트가 증가합니다. 참조가 사라지면 카운트가 감소합니다.

가비지 수집: 참조 카운트가 0이 되는 순간, 즉 더 이상 그 객체를 참조하는 변수가 없을 때, 해당 객체는 가비지로 간주되어 메모리에서 해제됩니다.

장점: 간단하고 실시간으로 객체의 수명을 관리할 수 있습니다.

단점: 순환 참조가 발생할 경우, 서로를 참조하는 객체들의 카운트가 0이 되지 않아 메모리 누수가 발생할 수 있습니다.

2. 마크-스윕 (Mark-and-Sweep)

작동 원리: 이 알고리즘은 두 단계로 나뉩니다.

- 마크 단계: 프로그램의 루트(전역 변수, 스택에 있는 변수 등)에서 시작하여, 접근 가능한 모든 객체를 탐색하면서 '마크'를 합니다. 이 과정에서 참조되는 객체들은 마크됩니다.

- 스윕 단계: 모든 객체를 순회하며 마크가 되어 있지 않은 객체를 찾아 메모리에서 해제합니다.

장점: 순환 참조 문제를 해결할 수 있으며, 참조되지 않는 객체를 효과적으로 수집할 수 있습니다.

단점: 가비지 수집 과정이 비동기적이지 않기 때문에, 프로그램의 성능에 영향을 줄 수 있습니다.

## 🤔+추가적으로 알아야 할 트레이드오프

자동적인 가비지 콜렉션을 통해, 메모리 관리에 시간을 소모하는 대신 애플리케이션 구현에 집중할 수 있습니다. 하지만 알아야 할 몇 가지 트레이프오프가 존재합니다.

### 🚨메모리 사용량

알고리즘 상 정확히 언제 메모리가 더 이상 필요하지 않은 것인지를 알 수 없다는 점을 생각해보면, `자바스크립트 애플리케이션은 실제로 필요한 것보다 더 많은 메모리를 사용하게 될 것`입니다.

객체가 쓰레기로 표시되더라도, 할당된 메모리를 수집할 시기와 여부를 결정하는 것은 결국 가비지 콜렉터에게 달려 있습니다.

만약 애플리케이션이 가능한 메모리 효율적이어야 하는 경우, 보다 로우 레벨의 언어를 사용하는 것이 좋습니다. 그러나 여기에는 트레이프오프가 수반된다는 점을 명심하세요.

### 🚨성능

쓰레기를 수집하는 알고리즘은 사용되지 않는 객체들을 청소하기 위해 주기적으로 실행되고 있습니다.

이것의 문제는 개발자가 정확히 언제 이러한 일이 일어날지를 모른다는 것입니다.

많은 양의 쓰레기를 수집하거나, 빈번하게 쓰레기를 수집하면 일정 수준의 컴퓨팅 파워가 필요할 것이므로 성능에 영향을 미칠 수 있습니다.

그러나 그 영향은 대개 사용자나 개발자에게 눈에 띄지는 않습니다.

## 🤔+추가적으로 알아야 할 메모리 누수

메모리 관리에 대한 이러한 지식들로 무장하고, 가장 일반적인 메모리 누수 사례를 살펴보겠습니다.

배후에서 무슨 일이 일어나고 있는지를 이해한다면, 문제를 쉽게 피할 수도 있다는 것을 알게 될 것입니다.

#### 전역 변수

전역 변수에 데이터를 저장하는 것은 가장 일반적인 유형의 메모리 누수일 것입니다.

예를 들어 브라우저에서는 const나 let 키워드 대신 var를 사용한다거나 아예 생략해버리는 경우, 엔진이 변수를 window 객체에 할당하게 됩니다. function 키워드로 정의한 함수도 마찬가지입니다.

user = getUser();
var secondUser = getUser();
function getUser() {
return 'user';
}
user, secondUser, getUser() 모두 window에 할당됩니다.

이는 전역 스코프에 정의된 변수 및 함수에만 적용됩니다. 이에 대해 더 알고 싶다면 자바스크립트의 스코프를 설명하는 글을 확인하세요.

실수로 루트 객체에 변수를 추가하는 것 외에도, 의도적으로 이 작업을 수행할 수 있는 많은 경우가 존재합니다.

전역 변수를 사용할 수는 있지만, 더 이상 필요하지 않으면 공간을 확보해 주어야 합니다. 메모리를 해제하려면 변수에 null을 할당하세요.

window.users = null;

#### 잊어버린 타이머 및 콜백

타이머와 콜백을 잊어버리면 애플리케이션의 메모리 사용량이 증가할 수 있습니다. 특히 단일 페이지 애플리케이션(SPA)에서 이벤트 리스너와 콜백을 동적으로 추가할 때 주의해야 합니다.

// 잊어버린 타이머
const object = {};
const intervalId = setInterval(function() {
// 여기에서 사용된 모든 것들은 interval이 클리어될 때까지 수집되지 않습니다
doSomething(object);
}, 2000);
위 코드는 2초마다 함수를 실행합니다. interval이 취소되지 않는 한, 여기서 참조된 객체들은 수집되지 않습니다. 더 이상 필요하지 않게 된 interval은 아래와 같이 취소해야 합니다.

clearInterval(intervalId);
이는 특히 SPA에서 중요합니다. 다른 페이지로 이동할 때에도 여전히 백그라운드에서 실행될 것이기 때문입니다.

#### 잊어버린 콜백

나중에 제거되는 버튼에 onclick 이벤트 리스너를 추가한다고 가정해 보겠습니다.

구식 브라우저는 리스너를 수집할 수 없었지만, 요즘에는 더 이상 문제가 되지는 않습니다.

그래도 더 이상 필요하지 않으면 이벤트 리스너를 제거하는 것이 좋습니다.

const element = document.getElementById('button');
const onClick = () => alert('hi');

element.addEventListener('click', onClick);
element.removeEventListener('click', onClick);
element.parentNode.removeChild(element);

#### DOM 참조

이 메모리 누수는 이전의 사례들과 유사한 경우입니다.

`자바스크립트에 DOM 엘리먼트를 저장할 때 발생`합니다.

```
const elements = [];
const element = document.getElementById('button');

elements.push(element); // DOM 엘리멘트를 저장 중

function removeAllElements() {
    elements.forEach((item) => {
        document.body.removeChild(document.getElementById(item.id))
    });
}
```

`엘리먼트를 제거할 때, 배열에서도 제거해 주어야 합니다.`

그렇지 않으면 DOM 엘리먼트가 수집될 수 없습니다.

```
const elements = [];
const element = document.getElementById('button');

elements.push(element);

function removeAllElements() {
    elements.forEach((item, index) => {
        document.body.removeChild(document.getElementById(item.id));

        // 배열에서 엘리먼트를 제거하면, DOM과 동기화된 상태로 유지됩니다.
        elements.splice(index, 1);
    });
}
```

모든 DOM 엘리먼트는 부모 노드에 대한 참조도 유지하기 때문에, `가비지 콜렉터가 엘리먼트의 부모와 자식을 수집하는 것을 방지`할 수 있습니다.
